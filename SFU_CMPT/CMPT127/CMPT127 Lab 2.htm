<!DOCTYPE html>
<!-- saved from url=(0054)http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    
    <title>CMPT127 Lab 2</title>
    
     <!-- Please don't change internal links and refs to absolute paths -->
    <link rel="stylesheet" href="./CMPT127 Lab 2_files/style.css">
    <!--<link rel="stylesheet" href="../taskcount.css">NOT FOUND -->
	<link rel="icon" href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/Images/favicon.ico" type="image/x-icon">
    
    <!-- Code syntax highlighting -->
    <!--<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"> NOT FOUND -->
	<link rel="stylesheet" type="text/css" href="./CMPT127 Lab 2_files/prettify.css">	

    <!-- force printing a line number in every line when prettyprinting -->
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>
<body data-feedly-mini="yes">

<div class="lab">
<h1>Laboratory 2: Functions and Arrays</h1>

<h4>Functions, arrays, C character strings, arguments to main, header files</h4>

<div id="floatingCornerLeft">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&amp;dq=%22Computer+lieben+Frauen&amp;hl=en&amp;sa=X&amp;ei=H9SoUuCrBI_YoASa2oCADQ&amp;ved=0CEcQ6AEwAA"><img src="./CMPT127 Lab 2_files/balloon0.jpg" height="150"></a>
</div>

<div id="floatingCornerRight">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&amp;dq=%22Computer+lieben+Frauen&amp;hl=en&amp;sa=X&amp;ei=H9SoUuCrBI_YoASa2oCADQ&amp;ved=0CEcQ6AEwAA"><img src="./CMPT127 Lab 2_files/balloon1.jpg" height="150"></a>
</div>


<h3>Goals</h3>
<p>After this lab you will be able to
</p><ol>
<li>Create and use functions</li>
<li>Create and use statically allocated arrays</li>
<li>Create and use text strings (null-terminated character arrays)</li>
<li>Build programs from multiple source files
</li><li>Create and use header files containing function declarations
</li><li>Use arguments passed to main()
</li><li>Compile a program from two source files.
</li><li>Test a function for correctness.
<!-- <li>Use assert statements as a basic quality assurance strategy. -->
</li></ol>


<h3>Tasks</h3>


<ol>
<li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_funcs">Min/max</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_identical">Identical</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_reverse">Reverse</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_scrambled">Scrambled</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_argv">Contains</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_redirect">Count</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_censored">CENSORED</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_lfreq">Letter frequency</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_vgraph">Vertical graph</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/2/#t_inrectangle">InRectangle</a>
</li></ol>


<h3>Setup</h3>

<div class="steps">
In the terminal:
<ol>
<li>Find or checkout a working copy of your repo. See the instructions in Lab 1 if you can't remember how. 
</li><li>cd to the root of your working copy
</li><li>Fetch the file(s) you need for Lab 2, stored in a compressed <a href="http://en.wikipedia.org/wiki/Tar_(computing)">tar archive</a>:
<pre>$ wget http://www.cs.sfu.ca/~vaughan/2.tgz</pre>
</li><li>Expand the archive into the current directory:
<pre>$ tar xzf 2.tgz</pre>
</li><li>Add the new directory "2" to your repo:
<pre>$ svn add 2</pre>
</li><li>Change directory into 2, which will be our lab 2 working directory:
<pre>$ cd 2</pre>
</li></ol>

</div>

<div class="task" id="t_func1">
<h2 id="t_funcs">1. Function definitions, declarations and header files</h2>

<h3>Guide</h3>

<p>C is a <a href="http://en.wikipedia.org/wiki/Procedural_programming_language">structured, procedural programming language</a>, that is, it supports the definition of isolated, self-contained blocks of code that can be re-used as components of larger programs. In C and Python these are called <i>functions</i>, but other languages call them <i>procedures, subroutines</i>, or <i>methods</i>.

</p><p>Given a well-designed function, you can often use it for what it does, and ignore the internal details of how it works. This idea of functional <i>encapsulation</i> makes it feasible for humans to write complex programs by breaking them down into small, more manageable pieces. You have already used several functions provided by the standard library, such as <tt>printf</tt> and <tt>floor</tt>, without seeing how they were implemented. One such function is max(), which could be implemented and used as follows:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">// returns the larger of the two arguments</span></li><li class="L1"><span class="kwd">int</span><span class="pln"> max</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> x </span><span class="pun">&gt;</span><span class="pln"> y </span><span class="pun">)</span><span class="pln"> </span></li><li class="L4"><span class="pln">  </span><span class="pun">{</span></li><li class="L5"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> x</span><span class="pun">;</span></li><li class="L6"><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span></li><li class="L7"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> y</span><span class="pun">;</span></li><li class="L8"><span class="pun">}</span></li><li class="L9"><span class="pln">&nbsp;</span></li><li class="L0"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">11</span><span class="pun">;</span></li><li class="L3"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">12</span><span class="pun">;</span></li><li class="L4"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"The max of our numbers is %d\n"</span><span class="pun">,</span><span class="pln"> max</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">);</span></li><li class="L5"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L6"><span class="pun">}</span></li></ol></pre>

<p>
</p><p>Reading the first 8 lines of code top-to-bottom, left-to-right, we see:
</p><ul>
<li>Line 1: A comment describing what the following function does. This is optional but good style.
</li><li>Lines 2-8 are the function definition, as follows:
 </li><li> The result, or <i>return value</i> of running this function is of type <tt>int</tt>
</li><li>The name of the function is <tt>max</tt>
</li><li>The function takes two integer arguments called <tt>x</tt> and <tt>y</tt>
</li><li>The <i>body</i> of the function, i.e. the code that will execute when the function is called, starts at <tt>{</tt>
</li><li>In the body of the function, the keyword <tt>return</tt> evaluates the expression to it's right which becomes the function's <i>return value</i>, then exits the function.
</li><li>The <i>body</i> of the function ends at the closing <tt>}</tt>.
</li></ul>


<p>Having been <i>defined</i> in lines 2 to 8, function <tt>max()</tt> is <i>called</i> on line 15. The values of integers <tt>a</tt> and <tt>b</tt> are assigned to <tt>x</tt> and <tt>y</tt> inside max(), the function does its work, and the return value is passed as the second argument to <tt>printf()</tt>.

</p><p>The syntax for C functions is

</p><pre class="prettyprint prettyprinted"><span class="pln">type functionName</span><span class="pun">(</span><span class="pln"> type arg_name1 </span><span class="pun">[,</span><span class="pln"> type arg_name2</span><span class="pun">,</span><span class="pln"> </span><span class="pun">...]</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="com">// code-block function body enclosed by curly braces</span><span class="pln">
</span><span class="pun">}</span></pre>

<p>Note that <tt>main()</tt> itself is a normal function. The system calls it to start the program. 

</p><p>The name "function" is a little unfortunate, since these are not the same as mathematical functions. Mathematical functions express relationships, while program functions perform sequences of operations on data. To see the difference, consider the function <tt>max()</tt> above and the following function <tt>output()</tt>: 

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="kwd">void</span><span class="pln"> output</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> val </span><span class="pun">)</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"the value is %.2f\n"</span><span class="pun">,</span><span class="pln"> val </span><span class="pun">);</span></li><li class="L3"><span class="pun">}</span></li></ol></pre>

<p>where <tt>void</tt> is a special type that means "nothing". Since there is nothing to return, we can omit the <tt>return</tt> statement and the function will finish at the end of the code block.

</p><p>Clearly <tt>output()</tt> does not describe a relationship between entities; instead it causes useful things to happen. Strictly speaking this is true of the C function <tt>max()</tt> as well: it <i>implements</i> the mathematical function max() by returning the largest of its arguments. 

</p><p>We are stuck with the C convention of calling our procedures "functions". In practice this is not usually a problem. We will return to the differences between "true" functions and C functions later in a discussion of software engineering approaches.



</p><h4>Multiple arguments</h4>

<p>As the syntax above indicates, function definitions can specify an arbitrary number of arguments, for example:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="kwd">double</span><span class="pln"> volume</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> height</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> depth </span><span class="pun">)</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> width</span><span class="pun">*</span><span class="pln">height</span><span class="pun">*</span><span class="pln">depth</span><span class="pun">;</span></li><li class="L3"><span class="pun">}</span></li></ol></pre>

<p>However, C functions can have only a single return value. Other languages such as Lisp and Go support  multiple return values, so this asymmetry between the number of arguments and results was a design decision in C. It keeps the syntax simple. 

</p><h4>Functions in functions</h4>
<p>Since main() is a function, it should be apparent that functions
can call other functions. In general a function may call any other
function. One interesting situation is when a function calls itself, a
process called <i>recursion</i>. Many algorithms are elegantly
expressed as recursive functions. You may have seen this idea before: proof by induction relies on it.

</p><h4>Function Declarations</h4>
Above we looked at three function definitions: max(), output() and volume(). A function can be called in a C source code file below its definition. Why only below? The compiler reads the source file from top to bottom. If it sees a call of function foo(), it doesn't know anything about that function. Did you specify the right number and type of arguments? There's no way to know. The compiler will complain.

<p>When you want to use a function that is not defined in your source file, for example a standard library function, we need some way to tell the compiler the name of the function, its arguments and return type. The implementation of the function will be provided from a library or some other source file. 

</p><p>A function declaration is the same as its definition, but with the function body replaced by a semicolon. Thus for volume() above, a matching declaration is:

</p><pre class="prettyprint prettyprinted"><span class="kwd">double</span><span class="pln"> volume</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> height</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">double</span><span class="pln"> depth </span><span class="pun">);</span></pre>

<h4>Header files</h4>
Your code almost always begins by including some header files:

<pre class="prettyprint prettyprinted"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;math.h&gt;</span><span class="pln">
</span><span class="pun">(</span><span class="pln">etc</span><span class="pun">)</span></pre>

<p>Recall that <tt>#include</tt> copies the contents of the indicated file into the current source file. Specifying the name of the header file <tt>&lt;like this&gt;</tt> forces the compiler to look for the file in the directories where your compiler was installed. To specify file you wrote yourself put the filename in quotes  <tt>"like this"</tt>. For example:

</p><pre class="prettyprint prettyprinted"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"> </span><span class="com">// a system-supplied header</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">"myheader.h"</span><span class="pln"> </span><span class="com">// a header I wrote myself</span></pre>

<p>The quotes version understands paths relative to the current directory, and absolute paths, e.g.:

</p><pre class="prettyprint prettyprinted"><span class="com">#include</span><span class="pln"> </span><span class="str">"myheader.h"</span><span class="pln"> </span><span class="com">// in the current directory</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">"include/myheader.h"</span><span class="pln"> </span><span class="com">// in a subdirectory</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">"../myheader.h"</span><span class="pln"> </span><span class="com">// in the parent directory</span><span class="pln">
</span><span class="com">#include</span><span class="pln"> </span><span class="str">"/opt/local/include/myheader.h"</span><span class="pln"> </span><span class="com">// an absolute path</span></pre>



<p>
C header files usually contain mostly function declarations. In the case of the standard library the implementations of these functions were pre-compiled for you into code <i>libraries</i>  and shipped with your compiler to save you time. The required libraries are <i>linked</i> into your program at the last step of compilation. The library containing printf() is used so often it is linked by default. The math library containing floor(), etc. is used less often, so we have to request it in in the compile command. It is still used a lot, so <a href="http://en.wikipedia.org/wiki/Dennis_Ritchie">the designer</a> gave it the nice short name "m". 

</p><pre>$ gcc mycode.c -lm </pre>

<p>Header files also provide important constant values, such as the
special value EOF (usually -1) returned by scanf() when reaching the end of a
file. Occasionally they also declare global variables. 

</p><p>Now you know how to define and declare functions, and what header files do.


</p><h3>Using multiple source files</h3>

<p>Function declarations and header files are also used when breaking your own code up into multiple source files. For example, in your working directory you have the source files funcs.c containing useful function definitions and main.c containing your main program:

</p><p>Contents of funcs.c:
</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">// returns the larger of the two arguments</span></li><li class="L1"><span class="kwd">int</span><span class="pln"> max</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> x </span><span class="pun">&gt;</span><span class="pln"> y </span><span class="pun">)</span><span class="pln"> </span></li><li class="L4"><span class="pln">  </span><span class="pun">{</span></li><li class="L5"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> x</span><span class="pun">;</span></li><li class="L6"><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span></li><li class="L7"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> y</span><span class="pun">;</span></li><li class="L8"><span class="pun">}</span></li><li class="L9"><span class="pln">&nbsp;</span></li><li class="L0"><span class="com">// returns the smaller of the two arguments</span></li><li class="L1"><span class="kwd">int</span><span class="pln"> min</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> x </span><span class="pun">&lt;</span><span class="pln"> y </span><span class="pun">)</span><span class="pln"> </span></li><li class="L4"><span class="pln">  </span><span class="pun">{</span></li><li class="L5"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> x</span><span class="pun">;</span></li><li class="L6"><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span></li><li class="L7"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> y</span><span class="pun">;</span></li><li class="L8"><span class="pun">}</span></li></ol></pre>

<p>Contents of main.c:
</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L3"><span class="pun">{</span></li><li class="L4"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">11</span><span class="pun">;</span></li><li class="L5"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">12</span><span class="pun">;</span></li><li class="L6"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"The max of our numbers is %d\n"</span><span class="pun">,</span><span class="pln"> max</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">));</span></li><li class="L7"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"The min of our numbers is %d\n"</span><span class="pun">,</span><span class="pln"> min</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">));</span></li><li class="L8"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L9"><span class="pun">}</span></li></ol></pre>

<p>Given multiple source files on its command line, the compiler will attempt to compile them all into one program. Try this now:

</p><pre class="steps">$ gcc -Wall funcs.c main.c</pre>

<p>The <tt>-Wall</tt> compiler option enables "all warnings". The compiler will be very strict.

</p><p>With these files as they are you will get warnings and possibly errors complaining that in main.c min() and max() and not properly declared. The exact message you get depends on your compiler vendor and version, but in CSIL we get:

</p><pre class="prettyprint prettyprinted"><span class="pln">main</span><span class="pun">.</span><span class="pln">c</span><span class="pun">:</span><span class="lit">7</span><span class="pun">:</span><span class="lit">45</span><span class="pun">:</span><span class="pln"> warning</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">implicit</span><span class="pln"> declaration of </span><span class="kwd">function</span><span class="pln"> </span><span class="str">'max'</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> invalid </span><span class="kwd">in</span><span class="pln"> C99 
 </span><span class="pun">[-</span><span class="typ">Wimplicit</span><span class="pun">-</span><span class="kwd">function</span><span class="pun">-</span><span class="pln">declaration</span><span class="pun">]</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"The max of our numbers is %d\n"</span><span class="pun">,</span><span class="pln"> max</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">));</span><span class="pln">
                                            </span><span class="pun">^</span><span class="pln">
main</span><span class="pun">.</span><span class="pln">c</span><span class="pun">:</span><span class="lit">8</span><span class="pun">:</span><span class="lit">45</span><span class="pun">:</span><span class="pln"> warning</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">implicit</span><span class="pln"> declaration of </span><span class="kwd">function</span><span class="pln"> </span><span class="str">'min'</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> invalid </span><span class="kwd">in</span><span class="pln"> C99 
 </span><span class="pun">[-</span><span class="typ">Wimplicit</span><span class="pun">-</span><span class="kwd">function</span><span class="pun">-</span><span class="pln">declaration</span><span class="pun">]</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"The min of our numbers is %d\n"</span><span class="pun">,</span><span class="pln"> min</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">));</span><span class="pln">
                                            </span><span class="pun">^</span><span class="pln">
</span><span class="lit">2</span><span class="pln"> warnings generated</span><span class="pun">.</span></pre>


<h3>Requirements</h3>

<p>First, check that you completed the Setup section above, so your current working directory is <tt>&lt;repo working copy&gt;/2</tt> . The shell command <tt>pwd</tt> prints the current working directory.

<!--
<pre class="steps">$ pwd
/Users/vaughan/CMPT118-1141-vaughan/2
</pre>
-->

</p><ol class="req">
<li>Create a new file called <tt>funcs.h</tt> that contains function declarations for all the functions in <tt>funcs.c</tt>. Edit the file main.c to #include the new header file. 
</li><li>The finished code must compile with this command with no errors or warnings. 
<pre>$ gcc main.c funcs.c</pre>
</li><li>The finished code must output <pre>The max of our numbers is 12
The min of our numbers is 11
</pre>
</li></ol>

<h3>Testing and Submitting</h3>

<p>The compiler will produce informative complaints if your declarations are not correct. Read the compiler output very carefully, starting with the top lines. 

</p><div class="steps">
<p>Submit by adding your header file and committing your changes:
</p><pre>$ svn add funcs.h
$ svn commit -m "task1 submit"
</pre>
</div>

</div>

<div class="task" id="t_identical">
<h2>2. Arrays</h2>

<h3>Guide</h3>

<p>In C any type can be used to create both simple variables and arrays:

</p><pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a</span><span class="pun">;</span><span class="pln">       </span><span class="com">// a single integer</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln">  </span><span class="com">// an array of 100 integers</span><span class="pln">

</span><span class="kwd">char</span><span class="pln"> c</span><span class="pun">;</span><span class="pln">      </span><span class="com">// a single character</span><span class="pln">
</span><span class="kwd">char</span><span class="pln"> d</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln"> </span><span class="com">// an array of 100 characters</span></pre>

Array elements are accessed by index, counting from 0:

<pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln"> </span><span class="com">// an array of 100 integers</span><span class="pln">

b</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">99</span><span class="pun">;</span><span class="pln"> </span><span class="com">// set the first element of b</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">42</span><span class="pun">];</span><span class="pln"> </span><span class="com">// get the 43rd element of b</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> f </span><span class="pun">=</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln"> </span><span class="com">// OOPS! this is the 101st element of a 100-element array</span></pre>


<p>C arrays have some important limitations compared to arrays/vectors in other languages:
</p><ol>
<li>All elements of the array are the same type;
</li><li>Array sizes are fixed at creation time;
</li><li>The value of array elements is not initialized;
</li><li>Access to elements is not bounds checked (i.e. lookups are not checked to make sure  (0 &lt;= index &lt; array size)).
</li></ol>

<p>These limitations mean that C arrays must be used carefully but are <i>very fast indeed</i>. There is a trivial amount of overhead in accessing data from an array compared to a normal variable. There is also very little cost to creating arrays. For these reasons C programmers use native arrays a lot despite the limitations.

</p><p>Arrays are allocated as contiguous chunk of memory, of size (array-length * sizeof(type)) bytes. The name of the array can be used like a pointer to the first byte of the first element in the array. The memory is automatically freed when the array variable goes out of scope. And that is all there is to implementing arrays in C. It is an incredibly simple and efficient design. 

</p><p>Because the name of an array can be used like a pointer, these things are true:

</p><pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span><span class="pln">
</span><span class="pun">&amp;</span><span class="pln">b</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> b</span><span class="pun">;</span><span class="pln"> 
</span><span class="pun">*(</span><span class="pln">b</span><span class="pun">+</span><span class="lit">5</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">5</span><span class="pun">];</span><span class="pln">
</span><span class="pun">*(</span><span class="lit">5</span><span class="pun">+</span><span class="pln">b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">5</span><span class="pun">];</span><span class="pln">
</span><span class="pun">(</span><span class="lit">5</span><span class="pun">+</span><span class="pln">b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">b</span><span class="pun">[</span><span class="lit">5</span><span class="pun">];</span></pre>

<p>Most people find the square-bracket array-indexing syntax easier to read than pointer arithmetic, but they are exactly equivalent to the compiler.


</p><h3>Passing arrays to functions</h3>
<p>Since array variables can be used like pointers, you can pass them into functions as such. Consider this code:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdlib.h&gt;</span></li><li class="L1"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L2"><span class="pln">&nbsp;</span></li><li class="L3"><span class="com">// return the largest int in the array</span></li><li class="L4"><span class="com">// (pointer syntax)</span></li><li class="L5"><span class="kwd">int</span><span class="pln"> array_max_ptr</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">*</span><span class="pln"> arr</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">)</span></li><li class="L6"><span class="pun">{</span></li><li class="L7"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> max </span><span class="pun">=</span><span class="pln"> arr</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span></li><li class="L8"><span class="pln">   </span><span class="kwd">for</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">len</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span></li><li class="L9"><span class="pln">   </span><span class="pun">{</span></li><li class="L0"><span class="pln">      </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> max </span><span class="pun">)</span></li><li class="L1"><span class="pln">      </span><span class="pun">{</span></li><li class="L2"><span class="pln">         max </span><span class="pun">=</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span></li><li class="L3"><span class="pln">      </span><span class="pun">}</span></li><li class="L4"><span class="pln">   </span><span class="pun">}</span></li><li class="L5"><span class="pln">&nbsp;</span></li><li class="L6"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> max</span><span class="pun">;</span></li><li class="L7"><span class="pun">}</span></li><li class="L8"><span class="pln">&nbsp;</span></li><li class="L9"><span class="com">// return the largest int in the array</span></li><li class="L0"><span class="com">// (preferred array-specific syntax)</span></li><li class="L1"><span class="kwd">int</span><span class="pln"> array_max_brackets</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[],</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">)</span></li><li class="L2"><span class="pun">{</span></li><li class="L3"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> max </span><span class="pun">=</span><span class="pln"> arr</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span></li><li class="L4"><span class="pln">   </span><span class="kwd">for</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">len</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span></li><li class="L5"><span class="pln">   </span><span class="pun">{</span></li><li class="L6"><span class="pln">      </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> max </span><span class="pun">)</span></li><li class="L7"><span class="pln">      </span><span class="pun">{</span></li><li class="L8"><span class="pln">         max </span><span class="pun">=</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span></li><li class="L9"><span class="pln">      </span><span class="pun">}</span></li><li class="L0"><span class="pln">   </span><span class="pun">}</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> max</span><span class="pun">;</span></li><li class="L3"><span class="pun">}</span></li><li class="L4"><span class="pln">&nbsp;</span></li><li class="L5"><span class="kwd">const</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> sz </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span></li><li class="L6"><span class="pln">&nbsp;</span></li><li class="L7"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L8"><span class="pun">{</span></li><li class="L9"><span class="pln">   </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">sz</span><span class="pun">];</span></li><li class="L0"><span class="pln">   </span><span class="kwd">for</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">sz</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span></li><li class="L1"><span class="pln">   </span><span class="pun">{</span></li><li class="L2"><span class="pln">      a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> random</span><span class="pun">();</span></li><li class="L3"><span class="pln">      printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"a[%u] == %d\n"</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></li><li class="L4"><span class="pln">   </span><span class="pun">}</span></li><li class="L5"><span class="pln">   </span></li><li class="L6"><span class="pln">   printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Largest was\n %d\n %d\n"</span><span class="pun">,</span><span class="pln"> </span></li><li class="L7"><span class="pln">	   array_max_ptr</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> sz </span><span class="pun">),</span><span class="pln">		       </span></li><li class="L8"><span class="pln">	   array_max_brackets</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> sz </span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span><span class="pln">		       </span></li><li class="L9"><span class="pln">   </span></li><li class="L0"><span class="pln">   </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L1"><span class="pun">}</span></li></ol></pre>

<p>The two versions of the array_max function have different syntax for passing the array, but are otherwise identical. You should almost always use the array-bracket syntax version ( <tt>int arr[]</tt> ) since it tells the human reader that an array is expected. The compiler doesn't care.

</p><p>Note that we had to pass the length of the array into both versions. C arrays do not know how long they are.

</p><p>Notice also that we used an <tt>unsigned int</tt> for the array length. This is sensible because negative-length arrays can not exist. Since the compiler will ensure that <tt>len</tt> does not have a negative value, we avoid a whole class of possible bugs. In general we always use the most restrictive type available so that the compiler can help us notice such mistakes.

</p><p class="step">Read this example carefully. Discuss it with your partner until you understand every bit before you move on.


</p><h3>Requirements</h3>
<ol class="req">
<li>Create a new file called identical.c, containing a single function that matches this declaration:

<pre>int identical( int a[], int b[], unsigned int len );</pre>
</li><li>Arrays <tt>a</tt> and <tt>b</tt> are both of length <tt>len</tt>, and contain arbitrary integer values. 
</li><li>The function identical() should return 1 iff arrays <tt>a</tt> and <tt>b</tt> contain the same values in the same order, or 0 otherwise.
</li><li><tt>len</tt> can have any unsigned int value, including 0.
</li><li>If <tt>len</tt> is 0 then identical() should return 1 (since the arrays have the same - empty - contents).
</li><li>You must not change the contents of the arrays.
</li></ol>


<p>Examples of arrays for which identical should return 1:
</p><ul>
<li>a = {10,15,20}, b = {10,15,20}
</li><li>a = {100}, b = {100}
</li><li>a = {5,2,2,3,4,5,5}, b = {5,2,2,3,4,5,5}
</li><li>a = {}, b = {} (i.e. len = 0)
</li></ul>

<p>Examples of arrays for which identical should return 0:
</p><ul>
<li>a = {1,1}, b = {1,2}
</li><li>a = {10,15,20}, b = {10,15,21}
</li><li>a = {1,2,3,4,5}, b = {5,3,4,2,2}
</li></ul>



<p>Example of a program that uses your function:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="com">// declaration of function implemented in identical.c</span></li><li class="L2"><span class="kwd">int</span><span class="pln"> identical</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[],</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[],</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">);</span></li><li class="L3"><span class="pln">&nbsp;</span></li><li class="L4"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L5"><span class="pun">{</span></li><li class="L6"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">15</span><span class="pun">,</span><span class="pln"> </span><span class="lit">20</span><span class="pun">};</span></li><li class="L7"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">20</span><span class="pun">,</span><span class="pln"> </span><span class="lit">15</span><span class="pun">};</span></li><li class="L8"><span class="pln">&nbsp;</span></li><li class="L9"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> identical</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">)</span></li><li class="L0"><span class="pln">  </span><span class="pun">{</span></li><li class="L1"><span class="pln">     printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"a and b are identical\n"</span><span class="pln"> </span><span class="pun">);</span></li><li class="L2"><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></li><li class="L3"><span class="pln">    printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"a and b are NOT identical\n"</span><span class="pln"> </span><span class="pun">);</span></li><li class="L4"><span class="pln">  </span><span class="pun">}</span></li><li class="L5"><span class="pln">  </span></li><li class="L6"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L7"><span class="pun">}</span></li></ol></pre>

<p>Note the curly-brace syntax for initializing arrays. This only
works when you first declare the array. The items listed between curly
braces must be constant values.

</p><h3>Testing and submission</h3>

<p>You should write your own test program with a main() function, using the example above as a guide.

</p><p>When your function works, add and commit only the single source file to the repo:

</p><pre>$ svn add identical.c
$ svn commit -m "identical is working"
</pre>


<div class="task" id="t_reverse">

<h2>3. Reverse</h2>

<h3>Requirements</h3>

<div class="req">
<ul>
<li>Create a new file called reverse.c, containing a single function that matches this declaration:

<pre>void reverse( int arr[], unsigned int len );</pre>

</li><li>Array <tt>arr</tt> is of length <tt>len</tt>, and contains arbitrary integer values.
</li><li>The function should reverse the contents of the array in-place, so that on returning, the array contains the same values as before, but in the reverse order.
</li></ul>

</div>

<h3>Guide</h3>

Example of a program that uses your function:

<pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="com">// declaration of function implemented in reverse.c</span></li><li class="L3"><span class="kwd">void</span><span class="pln"> reverse</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[],</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">);</span></li><li class="L4"><span class="pln">&nbsp;</span></li><li class="L5"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L6"><span class="pun">{</span></li><li class="L7"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">11</span><span class="pun">,</span><span class="pln"> </span><span class="lit">12</span><span class="pun">,</span><span class="pln"> </span><span class="lit">13</span><span class="pun">};</span></li><li class="L8"><span class="pln">  </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pun">;</span></li><li class="L9"><span class="pln">&nbsp;</span></li><li class="L0"><span class="pln">  reverse</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> len </span><span class="pun">);</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span></li><li class="L3"><span class="pln">  </span><span class="kwd">for</span><span class="pun">(</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">len</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span></li><li class="L4"><span class="pln">  </span><span class="pun">{</span><span class="pln">   </span></li><li class="L5"><span class="pln">     printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d "</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></li><li class="L6"><span class="pln">  </span><span class="pun">}</span></li><li class="L7"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span></li><li class="L8"><span class="pln">&nbsp;</span></li><li class="L9"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L0"><span class="pun">}</span></li></ol></pre>

<p>This code prints:

</p><pre>13 12 11
</pre>


<p>Notice that the length of the array </p><pre>a[]</pre> is not specified
explictly: it is set to the length of the initialization
list <pre>{11, 12, 13}</pre>, i.e. 3.

<h3>Testing and submission</h3>

<p>You should write your own test program with a main() function, using the example above as a guide.

</p><p>When your function works, add and commit only the single source file to the repo:

</p><pre>$ svn add reverse.c
$ svn commit -m "reverse is working"
</pre>

</div>


<div class="task" id="t_scrambled">
<h2>4. Scrambled</h2>

<p>Here is a programming puzzle that you might find in the real
world. It requires conditionals, loops and arrays. There is a simple
O(n) algorithm to solve the problem (i.e. you do not need to sort
anything).

</p><h3>Requirements</h3>
<ol class="req">
<li>Create a new file called scrambled.c, containing a single function that matches this declaration:

<pre>int scrambled( unsigned int a[], unsigned int b[], unsigned int len );</pre>
</li><li>Arrays <tt>a</tt> and <tt>b</tt> are both of length <tt>len</tt>, and contain values in the range [0 99] inclusive, only. 
</li><li>The function scrambled() should return 1 iff arrays <tt>a</tt> and <tt>b</tt> contain the same values in any order, or 0 otherwise.
</li><li><tt>len</tt> can have any unsigned int value, including 0.
</li><li>If <tt>len</tt> is 0 then scrambled() should return 1 (since the arrays have the same - empty - contents).
</li><li>You must not change the contents of the arrays.
</li><li>Use an algorithm that has run time linear in the array length <tt>n</tt>. Note that this means you <b>can not sort the arrays</b> since that can not be done in linear time.
</li></ol>

<p>Examples of arrays for which scrambled should return 1:
</p><ul>
<li>a = {10,15,20}, b = {10,15,20}
</li><li>a = {99}, b = {99}
</li><li>a = {1,2,3,4,5}, b = {5,3,4,2,1}
</li><li>a = {}, b = {} (i.e. len = 0)
</li><li>a = {2,1,3,4,5}, b = {1,2,4,3,5}
</li></ul>

<p>Examples of arrays for which scrambled should return 0:
</p><ul>
<li>a = {1,1}, b = {1,2}
</li><li>a = {10,15,20}, b = {10,15,21}
</li><li>a = {1,2,3,4,5}, b = {5,3,4,2,2}
</li></ul>


<p>Example of a program that uses your function:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="com">// declaration of function implemented in scrambled.c</span></li><li class="L2"><span class="kwd">int</span><span class="pln"> scrambled</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[],</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[],</span><span class="pln"> </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">);</span></li><li class="L3"><span class="pln">&nbsp;</span></li><li class="L4"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L5"><span class="pun">{</span></li><li class="L6"><span class="pln">  </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">15</span><span class="pun">,</span><span class="pln"> </span><span class="lit">20</span><span class="pun">};</span></li><li class="L7"><span class="pln">  </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">20</span><span class="pun">,</span><span class="pln"> </span><span class="lit">15</span><span class="pun">};</span></li><li class="L8"><span class="pln">&nbsp;</span></li><li class="L9"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> scrambled</span><span class="pun">(</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">)</span></li><li class="L0"><span class="pln">  </span><span class="pun">{</span></li><li class="L1"><span class="pln">     printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"b is a scrambled version of a\n"</span><span class="pln"> </span><span class="pun">);</span></li><li class="L2"><span class="pln">  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></li><li class="L3"><span class="pln">     printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"b has different contents to a\n"</span><span class="pln"> </span><span class="pun">);</span></li><li class="L4"><span class="pln">  </span><span class="pun">}</span></li><li class="L5"><span class="pln">  </span></li><li class="L6"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L7"><span class="pun">}</span></li></ol></pre>

<h3>Hint</h3>
<p>The number of different values you see is known and quite small.

</p><h3>Testing and submission</h3>

<p>You should write your own test program with a main() function,
using the example above as a guide. To reiterate: you must not submit
a complete program, though you will need to write one to test your
function yourself. You must submit a single file containing a single
function.

</p><p>When your function works, add and commit <b>only the file <tt>scrambled.c</tt> to the repo</b>:
</p><pre>$ svn add scrambled.c
$ svn commit -m "scrambled is working"
</pre>


<div class="task">
<h2 id="t_argv">5. Program arguments</h2>

<p>So far you have written programs that read their input from stdin. Another way to get data into a program is with program <i>arguments</i>. For example when using the shell's file copy program <tt>cp</tt> we type:

</p><pre>$ cp original copy</pre>

<p><tt>cp</tt> is not using stdin, so how does it learn about the filenames to read from and copy to? The answer is as arguments to main(). Your program must have a single main function and it can be declared like this if it needs no arguments from the outside world:

</p><pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span></pre>

or, if it needs arguments, like this:

<pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> argv</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span></pre>


<p>These two arguments work for <i>any</i> possible arguments to your program. This is quite a clever design, and it works by using arrays and pointers.

</p><p>The arguments are interpreted as follows.

</p><p><tt>int argc</tt> is the number of arguments passed into main, plus one. For the <tt>cp original copy</tt> example, this is 3.  

</p><p><tt>char* argv[]</tt> is an array of char pointers. The argv array is  <tt>argc</tt> pointers long. The zeroth entry in argv is always the program's own name (what use is this?). The subsequent entries are the program arguments in order. For our cp example the contents of the array are:

</p><pre>argv[0] : "cp"
argv[1] : "original"
argv[2] : "copy"
</pre>

<p> Recall that a C string is a character array containing a special NULL character (the character '\0' or value 0) to mark the end of its text: the <i>null terminator</i>. Each pointer in the argv array points to the first character in a character array. The result for our example can be drawn as follows, if we use arrows to represent pointers:

</p><p><img src="./CMPT127 Lab 2_files/argv.png">

</p><p>Thus we can sketch an implementation of cp like this:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> argv</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">)</span></li><li class="L1"><span class="pun">{</span></li><li class="L2"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> inputfile </span><span class="pun">=</span><span class="pln"> open</span><span class="pun">(</span><span class="pln"> argv</span><span class="pun">[</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> O_RDONLY </span><span class="pun">);</span><span class="pln"> </span><span class="com">// open a file for read only</span></li><li class="L3"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> outputfile </span><span class="pun">=</span><span class="pln"> open</span><span class="pun">(</span><span class="pln"> argv</span><span class="pun">[</span><span class="lit">2</span><span class="pun">],</span><span class="pln"> O_RW </span><span class="pun">|</span><span class="pln"> O_CREAT </span><span class="pun">);</span><span class="pln">  </span><span class="com">// create a new file for writing</span></li><li class="L4"><span class="pln">&nbsp;</span></li><li class="L5"><span class="pln">  </span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="com">// we haven't read everything from inputfile</span></li><li class="L6"><span class="pln">  </span><span class="pun">{</span></li><li class="L7"><span class="pln">     </span><span class="pun">...</span><span class="pln"> </span><span class="com">// read bytes from inputfile and write them to outputfile</span></li><li class="L8"><span class="pln">  </span><span class="pun">}</span></li><li class="L9"><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="com">// success!</span></li><li class="L0"><span class="pun">}</span></li></ol></pre>

<p>Function <tt>open()</tt> is called twice: once with argv[1], the
name of the file to copy (i.e. "original" in the example). Then open()
is called again with argv[2], the name of the destination file to copy
to (i.e. "copy" in the example).

<!--
<p>Did you figure out any reason why the program would want to know it's own name via the string in argv[0]? One neat example is the <tt>zip</tt> data compression utility and its partner <tt>unzip</t>. These can be implemented by the same program, if gram sees that it is called 'zip' it compresses, and when it sees that it is called 'unzip' it uncompresses. 
-->

</p><h4>I want numbers, not text strings</h4>

<p>Since main's arguments are stored as character strings,  another step is needed to convert strings that represent numbers into number types before you use them. The atoi() and atof() functions provided in the standard library convert strings to integers and floating point values respectively:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdlib.h&gt;</span><span class="pln"> </span><span class="com">// for atoi() and friends</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="com">// takes two arguments: an integer followed by a float</span></li><li class="L3"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> argv</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">)</span></li><li class="L4"><span class="pun">{</span></li><li class="L5"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> argc </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="com">// yes 3! argv[0] is the program name</span></li><li class="L6"><span class="pln">  </span><span class="pun">{</span></li><li class="L7"><span class="pln">     printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"I wanted 2 arguments\n"</span><span class="pln"> </span><span class="pun">);</span></li><li class="L8"><span class="pln">  </span><span class="pun">}</span></li><li class="L9"><span class="pln">&nbsp;</span></li><li class="L0"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> atoi</span><span class="pun">(</span><span class="pln"> argv</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></li><li class="L1"><span class="pln">  </span><span class="kwd">float</span><span class="pln"> f </span><span class="pun">=</span><span class="pln"> atof</span><span class="pun">(</span><span class="pln"> argv</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></li><li class="L2"><span class="pln">  </span><span class="pun">...</span></li><li class="L3"><span class="pun">}</span></li></ol></pre>

<p>The program can be run like so and work as expected:

</p><pre>$ ./a.out 5 3.14</pre>

<t3>Requirements</t3>
<ol class="req">
<li>Write a program called "contains" that takes two text strings as arguments and prints "true" followed by a newline if the second string is entirely contained within the first, or "false" followed by a newline otherwise. 
</li><li>The strings contain only ASCII characters and may be any length &gt; 0 characters. Strings in argv are always null-terminated.
</li></ol>

<p>This is an <a href="http://en.wikipedia.org/wiki/Substring">important problem in computer science</a>, with wide applications from searching the internet, to understanding text, to finding DNA matches. It's easy to state and easy to code. It gets interesting when the strings are long and you want to do it very efficiently. For now you can be happy with a simple solution to practice managing argv array and char strings.

</p><p>Example runs:
</p><pre>$ ./contains "I have a really bad feeling about this" "bad feeling"
true
$ ./contains "To be or not to be" "That is the question"
false 
$ ./contains "I am the walrus" "I am the walrus"
true
$ ./contains "the walrus" "I am the walrus"
false
$ ./contains "kmjnhbvc45&amp;^$bn" "."
false
</pre>

<p>Notice that the strings do not have quote characters around them when delivered to your program via argv. The quotes prevent the shell from breaking the strings up into individual words.

</p><p>You may find the standard library function strlen() useful. Read its manpage.

</p><p><b>NOTE: pay attention to the requirements, e.g. don't forget the newlines. </b>


</p><h3>Testing and submission</h3>

<p>Save your implementation as the single C source file  <tt>contains.c</tt>. When you think it works, add and commit <tt>contains.c</tt>.



</p></div>

<!--
<div class="homeworkbegins">
Lab session complete. Homework starts here.
</div>
-->

<div class="task">
<h2 id="t_redirect">6. Redirecting stdin and stdout</h2>

<p class="meta"> From here on, the guide section
will often include links to other material that can be crucial to
solving the task. You should practice consulting online references and
tutorials: this is a significant part of real-world programming. To
encourage you to practice, we use external links instead of writing everything out in the guide. To be absolutely clear: <b>not everything you need to know is contained in our instructions: you need to read around using the links and maybe searching online. This is deliberate and not cause for complaint!</b>

</p><h3>Guide</h3>

<p>You will find it tedious to type lots of text into your program's stdin. The shell has a powerful tool to help with this: <i>stream redirection</i>. This allows you to route the stdin and stdout for a program away from the console and into a file. For example, if we have a program called hello that prints "Hello world!\n" on stdout, we can do this:

</p><pre>$ ./hello &gt; myfile.txt
</pre>

This creates a new file myfile.txt. Anything written to stdout in the hello program is written to the file. To confirm this, inspect the contents of the file with cat:

<pre>$ cat myfile.txt
Hello world!
</pre>

<p>Similarly, we can take the contents of a file, and stream it into the standard input of our program. So if we have a program <tt>sort</tt> that reads lines from stdin, sorts them into lexical order then writes them on stdout, we can do this:

</p><p>Contents of file beatles.txt:
</p><pre>john
paul
george
ringo
</pre>
 
<pre>$ sort &lt; beatles.txt
george
john
paul
ringo
</pre>

<p>Input and output redirection can be used together:

</p><pre>$ sort &lt; beatles.txt &gt; sorted.txt
$ cat sorted.txt
george
john
paul
ringo
</pre>

<p>This is a very powerful mechanism that is great for testing with lots of different inputs. It's much more convenient to redirect a file into stdin than to type many lines followed by ctrl-d over and over. Make sure you understand file redirection!

</p><p>
<a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">Here is a terse but good introduction to BASH shell programming,</a> including a <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-3.html">section on redirection</a>.

</p><p>Here is an exercise that will make you glad you know about shell redirection:

</p><h3>Requirements</h3>

<ul class="req">
<li>Write a C program that counts the number of characters, words and lines read from standard input until EOF is reached.
</li><li>Assume the input is <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a> text of any length.
</li><li>Every byte read from stdin counts as a character except EOF.
</li><li>Words are defined as contiguous sequences of letters (a through z, A through Z) and the apostrophe ( ', value 39 decimal) separated by any character outside these ranges.
</li><li>Lines are defined as contiguous sequences of characters separated by newline characters ('\n').
</li><li> Characters beyond the final newline character will not be included in the line count.
</li><li>On reaching EOF, use this output command:
<pre class="prettyprint prettyprinted"><span class="pln">printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%lu %lu %lu\n"</span><span class="pun">,</span><span class="pln"> charcount</span><span class="pun">,</span><span class="pln"> wordcount</span><span class="pun">,</span><span class="pln"> linecount </span><span class="pun">);</span></pre>
<p>Where charcount, wordcount and linecount are all of type unsigned long int. You may need these large types to handle long documents. 
</p></li></ul>

<h3>Guide</h3>

<p>You may find the standard library function getchar() useful. Read its manpage.

</p><p>There's a handy standard program called <tt>wc</tt> that does a similar job, but it does not match the requirements exactly (it is a little more clever about word boundaries and will sometimes count fewer words than our simple program). Your program should agree with wc's character and line counts, as the logic for those is the same.

</p><h4>Escape characters</h4>

<a href="http://stackoverflow.com/questions/2414478/c-escaping-an-apostrophe-in-a-string">This Q&amp;A on StackOverflow gives advice on representing the apostrophe character using an <i>escape sequence</i></a>. StackOverflow is very useful indeed. 

<h3>Testing and submission</h3>

<p>Submit your solution as a complete program in a C source file <tt>count.c</tt>.

</p></div>

</div>

<div class="task">

<h2 id="t_censored">7. CENSORED</h2>

<h3>Requirements</h3>

<ul class="req">
<li>Write a C program called <tt>censor</tt> that takes any number of one-word text string arguments, each less than 128 characters long.
</li><li>"Word" is defined as in the previous task.
</li><li> The program copies text from stdin to stdout, except that any of the words seen in the input are replaced with the word "CENSORED".
</li><li>The argument and the input stream are both <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>.
</li><li>The input to stdin is of any length.
</li></ul>

<p>Example runs:
</p><pre>$ cat poem.txt
Said Hamlet to Ophelia,
I'll draw a sketch of thee,
What kind of pencil shall I use?
2B or not 2B? 
$ ./censor Ophelia &lt; poem.txt
Said Hamlet to CENSORED,
I'll draw a sketch of thee,
What kind of pencil shall I use?
2B or not 2B? 
</pre>

<pre>$ cat beatles.txt
paul
ringo
george
john
$ ./censor paul ringo john &lt; beatles.txt
CENSORED
CENSORED
george
CENSORED
</pre>


<h3>Testing and submission</h3>

<p>Submit your solution as a complete program in a C source file <tt>censored.c</tt>.

</p></div>


<div class="task">

<h2 id="t_lfreq">8. Letter frequency</h2>

<h3>Requirements</h3>

<div class="req">
<ul>
<li>Write a program that calculates the frequency of letter occurrences in text.
</li><li>Read ASCII text from standard input.
</li><li>On reaching EOF, print to stdout the normalized frequency of occurrence for each letter a-z that appeared in the input,  one per line, in alphabetical order using the format produced by <pre>printf( "%c %.4f\n", letter, freq);</pre>
</li><li>Letters that occur zero times should not appear in the output. 
</li><li>Characters other than lower and upper case letters should be ignored.
</li><li>Lower and upper case instances count as the same letter, e.g. 'a' and 'A' are both reported for the letter 'a' on the output.
</li><li>The frequencies reported should sum to approximately 1 (with a little slack for accumulation of printf rounding errors).
</li></ul>
</div>

<h4>Example runs</h4>

Assume you have named your executable <tt>lfreq</tt>. The first two example runs show the user entering the text manually in the terminal. The third and fourth runs have text piped in from a file (and the middle of the alphabet is omitted from the output for brevity). A text file <tt>happy_prince.txt</tt> containing a classic story in English is provided for testing.

<pre>$ ./lfreq 
aaab
a 0.7500
b 0.2500
</pre> 

<pre>$ ./lfreq 
q
q 1.0000
</pre> 

<pre>./lfreq &lt; happy_prince.txt 
a 0.0841
b 0.0140
c 0.0206
...
y 0.0240
z 0.0002
</pre>

<pre>$ ./lfreq &lt; "large novel in English.txt"
a 0.0817
b 0.0149
c 0.0278
...
y 0.0197
z 0.0001
</pre> 


<h3>Testing and submission</h3>

<p>Submit your solution as a complete program in a C source file <tt>letterfreq.c</tt>.

</p></div>

<div class="task" id="t_vgraph">

<h2>9. Vertical graph</h2>

<p>In Lab 1 we plotted a histogram horizontally. In order to plot a histogram vertically, we need to have finished reading all the input before we start drawing the graph on the output. An array is suitable for this. 
</p><p>A standard terminal window is 80 character-columns across. If we
limit the number of columns we can graph to a maximum of 80, we know
how large an array we need to allocate and this program is simple to
write.

</p><h3>Requirements</h3>

<div class="req">
<ol>
<li>Read integer values from stdin, separated by one or more spaces or newlines, until reaching EOF.
</li><li>The input is guaranteed to be well-formed.
</li><li>The input contains no more than 80 values.
</li><li>On standard output, render a simple vertical column graph
representation of the input values, in order left to right, using hash
'#' characters as shown in the examples below. The number of hashes
printed in each column should be equal to the corresponding input
value.
</li><li>The area above a completed column should be filled with space
characters. 
</li><li>Ignore empty lines. Do not output a column for an empty line.
</li><li>The entire graph must end with a newline character.
</li></ol>
</div>

<h3>Guide</h3>

Hint: you may find it helpful to draw your graphs upside down
(increasing down the screen) first, then change your code to flip the
output it up the right way.

<p></p><h3>Examples</h3>
<ol>
<li>Input: 
<pre>1 1 3 1</pre>
Output:
<pre>  # 
  # 
####
</pre>

<p>The requirements mean that the graph fills a rectangular area with hashes and spaces, so this example is printed as:
</p><pre>' ', ' ', '#', ' ', '\n' 
' ', ' ', '#', ' ', '\n' 
'#', '#', '#', '#', '\n' 
</pre>

<p>In particular, notice the spaces before the newlines on the first two lines. They are necessary.


</p></li><li>Input:
<pre>3 4 5</pre>
Output:
<pre>  #
 ##
###
###
###
</pre>

</li><li>Input:
<pre>0 3 0 4 5</pre>
Output:
<pre>    #
   ##
 # ##
 # ##
 # ##
</pre>

<p>Notice the empty columns that correspond to the zeros in the input, including the leading zero.

</p></li><li>Input: 
<pre>5
15
16
15
12
12
12
8
6
3
2
19
21
17
15
12
11
10
9
8
7
7
</pre>
Output:
<pre>            #         
            #         
           ##         
           ##         
           ###        
  #        ###        
 ###       ####       
 ###       ####       
 ###       ####       
 ######    #####      
 ######    ######     
 ######    #######    
 ######    ########   
 #######   #########  
 #######   ###########
 ########  ###########
#########  ###########
#########  ###########
########## ###########
######################
######################
</pre>
</li><li>Input: 
<pre>0
0
2
1
0
</pre>
Output:
<pre>  #  
  ## 
</pre>
</li></ol>


<h3>Testing and submission</h3>

<p>Submit your solution as a complete program in a C source file <tt>verticalgraph.c</tt>.

</p></div>


<div class="task" id="t_inrectangle">

<h2>10. In Rectangle</h2>

<p>In this task you must write a function that determines whether a point lies inside a rectangle. The point and rectangle are both specified using arrays of floating point values.

</p><h3>Requirements</h3>

<div class="req">
<ul>
<li>Write a function that matches the following declaration:

<pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> </span><span class="typ">InRectangle</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> pt</span><span class="pun">[</span><span class="lit">2</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> rect</span><span class="pun">[</span><span class="lit">4</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></pre>

</li><li>Argument pt[2] defines a point on the plane: pt[0] is the x-coordinate, pt[1] is the y-coordinate.
</li><li>Argument rect[4] defines a rectangle on the same plane. rect[0] and rect[1] define the x- and y- cordinates respectively of one corner of the rectangle. rect[2] and rect[3] define the opposite corner. 
</li><li>Coordinates may be any valid floating point value, including negative values.
</li><li>The function returns int 0 (false) for any point that lies outside the rectangle, and 1 (true) for any other point (i.e. points inside and on the boundary of the rectangle).
</li></ul>

</div>

<h3>Guide and Testing</h3>

<p>It is very common to represent geometric figures using small, fixed-size arrays like this. Note that the size of the arrays are specified in the function declaration. This allows the compiler to check that the function is called with a correctly-sized array. 

</p><p>Since this task calls for a function only, and not a complete program, you need to write a program to test your function. The test server contains a program that looks something like this:

</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">// declaration of function to test</span></li><li class="L1"><span class="kwd">int</span><span class="pln"> </span><span class="typ">InRectangle</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> pt</span><span class="pun">[</span><span class="lit">2</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">float</span><span class="pln"> rect</span><span class="pun">[</span><span class="lit">4</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></li><li class="L2"><span class="pln">&nbsp;</span></li><li class="L3"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pun">*</span><span class="pln"> argv</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">)</span></li><li class="L4"><span class="pun">{</span></li><li class="L5"><span class="pln">  </span><span class="com">// define a rectangle from (1,1) to (2,2)</span></li><li class="L6"><span class="pln">  </span><span class="kwd">float</span><span class="pln"> rect</span><span class="pun">[</span><span class="lit">4</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">1.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2.0</span><span class="pln"> </span><span class="pun">};</span></li><li class="L7"><span class="pln">&nbsp;</span></li><li class="L8"><span class="pln">  </span><span class="com">// define a point that is inside the rectangle</span></li><li class="L9"><span class="pln">  </span><span class="kwd">float</span><span class="pln"> p_in</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="lit">1.5</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.5</span><span class="pln"> </span><span class="pun">};</span></li><li class="L0"><span class="pln">&nbsp;</span></li><li class="L1"><span class="pln">  </span><span class="com">// define a point that is outside the rectangle</span></li><li class="L2"><span class="pln">  </span><span class="kwd">float</span><span class="pln"> p_out</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">2.5</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">};</span></li><li class="L3"><span class="pln">&nbsp;</span></li><li class="L4"><span class="pln">  </span><span class="com">// define a point that is on the edge of the rectangle</span></li><li class="L5"><span class="pln">  </span><span class="kwd">float</span><span class="pln"> p_edge</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">1.0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">};</span></li><li class="L6"><span class="pln">&nbsp;</span></li><li class="L7"><span class="pln">  </span><span class="com">// InRectangle() should return 0 (false) for points that are NOT in</span></li><li class="L8"><span class="pln">  </span><span class="com">// the rectangle, and non-zero (true) for points that are in the</span></li><li class="L9"><span class="pln">  </span><span class="com">// rectangle. Points on the edge are considered *in* the rectangle.</span></li><li class="L0"><span class="pln">&nbsp;</span></li><li class="L1"><span class="pln">  </span><span class="com">// test 1</span></li><li class="L2"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="typ">InRectangle</span><span class="pun">(</span><span class="pln"> p_in</span><span class="pun">,</span><span class="pln"> rect </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span></li><li class="L3"><span class="pln">  </span><span class="pun">{</span></li><li class="L4"><span class="pln">    puts</span><span class="pun">(</span><span class="pln"> </span><span class="str">"error: should return true for p_in."</span><span class="pln"> </span><span class="pun">);</span></li><li class="L5"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="com">// indicate error</span></li><li class="L6"><span class="pln">  </span><span class="pun">}</span></li><li class="L7"><span class="pln">&nbsp;</span></li><li class="L8"><span class="pln">  </span><span class="com">// test 2</span></li><li class="L9"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="typ">InRectangle</span><span class="pun">(</span><span class="pln"> p_out</span><span class="pun">,</span><span class="pln"> rect </span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span></li><li class="L0"><span class="pln">  </span><span class="pun">{</span></li><li class="L1"><span class="pln">    puts</span><span class="pun">(</span><span class="pln"> </span><span class="str">"error: should return false for p_out."</span><span class="pln"> </span><span class="pun">);</span></li><li class="L2"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="com">// indicate error</span></li><li class="L3"><span class="pln">  </span><span class="pun">}</span></li><li class="L4"><span class="pln">&nbsp;</span></li><li class="L5"><span class="pln">  </span><span class="com">// test 3</span></li><li class="L6"><span class="pln">  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> </span><span class="typ">InRectangle</span><span class="pun">(</span><span class="pln"> p_edge</span><span class="pun">,</span><span class="pln"> rect </span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span></li><li class="L7"><span class="pln">  </span><span class="pun">{</span></li><li class="L8"><span class="pln">    puts</span><span class="pun">(</span><span class="pln"> </span><span class="str">"error: should return true for p_edge."</span><span class="pln"> </span><span class="pun">);</span></li><li class="L9"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="com">// indicate error</span></li><li class="L0"><span class="pln">  </span><span class="pun">}</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="com">// all tests passed</span></li><li class="L3"><span class="pun">}</span></li></ol></pre>

<p>The code tests that the function works correctly with these parameters:

<br></p><center><img src="./CMPT127 Lab 2_files/InRectangle.png"></center>

<p>The actual server test is longer and more comprehensive than this: we give a simplified example for clarity. 

</p><p>Note the sytax for initializing arrays with constant values at compile-time, e.g. line 7. This only works for constant values, unfortunately. 

</p><p>You should <b>always</b> write a test for your functions. Consider an untested function to be incorrect. It helps to assume  the function was written by a complete idiot who has no idea what they are doing, even if the author was you. Then test the function to find out what craziness that daft person implemented. 

</p><p>Once a function passes all the tests you can think of, you might cautiously believe it might be correct. In software engineering, like any quality-focused pursuit, it helps to be skeptical. 

</p><h4>Compiling two files into one program</h4>

<p>Since  the file you submit must not contain a main() function (see Submission section below), it is conventient to make a test program from two source files: one containing the InRectangle() function, and one with main(). You can start out with the code above, and extend it to be a more thorough test.

</p><p>Recall from above that you can compile a single program from multiple source files by simply listing the sources on the compiler command line:

</p><pre>$ gcc -o test inrect.c main.c
</pre>

<p>

</p><h3>Submission</h3>

<p>Submit your solution as a C source file <tt>inrect.c</tt>. The file must not contain a main() function, even though you wrote one for testing. The server will compile your file along with it's own main(). Since there can only be one main(), if you provide a second, the compilation will fail. 

</p></div>


<!--
<div class="task">

<h2>Task template</h2>

<h3>Requirements</h3>

<div class="req">
<ul>
<li>item
</ul>
</div>

<h3>Guide</h3>

<h3>Testing</h3>

<h3>Submission</h3>

</div>
-->

<div class="labends">
Lab complete. <!-- <a href="../index.html">Back to the list of labs</a>.-->
</div>
</div> 






</div><div id="feedly-mini" title="feedly Mini tookit"></div></body></html>