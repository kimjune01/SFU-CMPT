<!DOCTYPE html>
<!-- saved from url=(0054)http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    
    <title>CMPT127 Lab 1</title>
    
     <!-- Please don't change internal links and refs to absolute paths -->
    <link rel="stylesheet" href="./CMPT127 Lab 1_files/style.css">
    <!--<link rel="stylesheet" href="../taskcount.css">NOT FOUND -->
	<link rel="icon" href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/Images/favicon.ico" type="image/x-icon">
    
    <!-- Code syntax highlighting -->
    <!--<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"> NOT FOUND -->
	<link rel="stylesheet" type="text/css" href="./CMPT127 Lab 1_files/prettify.css">	

    <!-- force printing a line number in every line when prettyprinting -->
    <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
</head>

<body data-feedly-mini="yes">

<div class="lab">
<h1>Laboratory 1: Getting started in C</h1>

<h4>Compiling, I/O, types, loops and using version control</h4>

<div id="floatingCornerLeft">
<a href="http://books.google.ca/books?id=RFJiAgAACAAJ&amp;dq=%22Computer+lieben+Frauen&amp;hl=en&amp;sa=X&amp;ei=H9SoUuCrBI_YoASa2oCADQ&amp;ved=0CEcQ6AEwAA"><img src="./CMPT127 Lab 1_files/balloon0.jpg" height="150"></a>
</div>

<div id="floatingCornerRight">
  <a href="http://books.google.ca/books?id=RFJiAgAACAAJ&amp;dq=%22Computer+lieben+Frauen&amp;hl=en&amp;sa=X&amp;ei=H9SoUuCrBI_YoASa2oCADQ&amp;ved=0CEcQ6AEwAA"><img src="./CMPT127 Lab 1_files/balloon1.jpg" height="150"></a>
</div>

<!-- 
<p class="todo">
Sections marked in grey are TO-DO and contain notes, incomplete bits, etc. 
-->

<p></p><h3>Goals</h3>
<p>After this lab you will be able to

</p><ol>
<li>Follow the instructions for subsequent labs.
</li><li>Compile and run a C program from the command line in Linux.
</li><li>Submit code for evaluation using a version control system. 
</li><li>Create and use variables of the native types and obtain their addresses.
</li><li>Perform basic input and output on the console.
</li><li>Link to the standard math library 
</li><li>Write loops using the <i>while</i> and <i>for</i> syntax.
</li><li>Write conditionals using the <i>if</i> syntax.
</li><li>Obtain the evaluation results through the version control system.
</li></ol>


<h3>Tasks</h3>

<!--
<p class="todo">
Idea: have a little javascript in here that fetches the test status for each task and shows it in this list?
-->

<ol>
<li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_hello">Compiling and Hello World</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_types">Data types and output</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_pointers">Pointers and input</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_conditions">Conditions</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_loops">Loops</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_stats">Simple statistics</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_drawhisto">Horizontal Histogram</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_pyramid1">Pyramid projection 1</a>
</li><li><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/#t_pyramid2">Pyramid projection 2</a>
<!--
<li><a href="#t_snugfit">Snug fit</a>
-->
</li></ol>

<h3>Setup</h3>

<p>In this class you will complete a weekly Lab. Each lab contains several tasks, small assignments that are submitted individually. The labs are automatically graded by our test server, which compiles and runs your code with various inputs and checks that the output is correct in each case. 

</p><p>We sometimes provide pre-written code or data using a <i>source code version control system (VCS)</i>. You submit your code using the same system. This is how professionals develop code.

</p><p>We use a popular Open Source VCS called <a href="http://subversion.apache.org/">Subversion</a>. We will
call it by its command line program name "svn" for short. You will
learn about what version control can do for you later, but for now
just follow along.

</p><p>Below we will walk through the process of downloading, or "checking out" a "working copy" of your personal source code repository. You will work inside this working copy directory, updating it, adding and modifying files, then submitting your changes to the server. 

</p><p>You can also update your working copy to fetch files that we add for you, including the results of the on-line tests.

</p><p class="meta"> The following section contains steps that you should perform. Whenever you see a section that looks like this, you should follow the instructions carefully. Don't move on until you have completed them. Seek help if necessary.

</p><p>The following instructions will get you set up for this lab. 

</p><p>When commands are given, they are prefixed with a dollar sign '$' and a space. Do not type this - it is just used to represent the command prompt. For example, the command to list the contents of the current directory is "ls". We write:
</p><pre>$ ls</pre>
and you type only <tt>ls</tt> at the command prompt and press return.



<div class="steps">

<ol>
<li>If you have a working copy of your repo, for example if you have just finished Lab 0, make that your current directory. It is called CMPT127-1164-jka79. Make sure this is your current working directory (i.e. 'cd' into it).

<p><b>If and only if you do not have a working copy</b> use this command to fetch one from the server:

</p><pre>$ svn co http://punch.cs.sfu.ca/svn/CMPT127-1164-jka79/
</pre>

<p> and then change directory into your new working copy
</p><pre>$ cd CMPT127-1164-jka79 </pre>

</li><li>Create a directory for this lab, called "1"

<pre>$ mkdir 1</pre>

</li><li>Add the new directory to the version control system, so it will become a permanent part of your repository:

<pre>$ svn add 1</pre>

</li><li>Commit your changes. This sends all the changes you made to the server, to create a new <i>revision</i> of your repository. Any future check outs will retrieve this new version.

<pre>$ svn commit -m "first try"</pre>

</li><li>Verify that this worked with the web interface to your repo. Click on the link <a href="http://punch.cs.sfu.ca/svn/CMPT127-1164-jka79/">http://punch.cs.sfu.ca/svn/CMPT127-1164-jka79/</a> to get there. When prompted you for your username/password, enter the same information that you would use to check your e-mail on SFU Connect.

<p>You should see your "handle" file, the empty directory "1", and a revision number greater than zero. 

</p></li><li>If you do not see these things, or you are baffled, review the steps above and check with a TA or instructor if necessary. 

</li><li>Change directory into "1"
<pre>$ cd 1</pre>


</li><li>Check that your current working directory ends with <tt>CMPT127-1164-jka79/1</tt>. The instructions below assume this is true. You can use the shell command <tt>pwd</tt> (print-working-directory):

<pre>$ pwd</pre>

</li><li>You're ready to continue with the lab.

</li></ol>

</div>

<div class="task" id="t_hello">
<h2>1. Compiling and Hello World!</h2> <!-- note task numbering is done automaticaly with css -->

<p>In this task you will write a very simple C program, compile it, run
it, and read its output. You will then test the program to make sure it is correct. When satisfied, you will submit the finished code to our automated
system for testing. 

</p><p>Why compile code? Languages like Python are run inside
an <i>interpreter</i>, a program that reads source code and executes
it as it goes along. In contrast C code is <i>compiled</i> into
programs that run directly on the computer. The compiler does not run
the program, instead it transforms it into runnable machine
code. Compiled programs do not have the overhead of the interpreter
when they run, so in theory they could run faster and use less memory,
at the cost of the extra compilation step. 

</p><p>Why C? The speed and small memory footprint of well-written C is the key to its popularity, along with the availability of a C compiler for almost every computer you can find, including small embedded devices. C also has good support for the low level operations needed to interact with hardware, while being tolerably easy for humans to read and write. C is a <i>lingua franca</i> for application, systems and embedded programmers. 

</p><p>Much of the software you use every day is written in C or a descendant language (<a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">some data here</a> and <a href="http://lang-index.sourceforge.net/"> and here</a>) and this has been true for many years. The most popular alternative is currently Java, which has a C++-like syntax but simplified memory management. Learning Java is easy if you know C++. 

</p><p class="meta">This is a simple but complete run-through of the work-flow you will use to complete most of the remaining tasks. Don't be concerned if you find this task or this lab trivial: tasks become more challenging soon enough.

</p><h3>Requirements</h3>
<p class="meta">The requirements section is very important: it describes what your submission must do to pass the automated tests. It is colored bright pink so you can't miss it. The requirement for this task is:

</p><div class="req">
<ul>
<li>Write a C program that writes the string "Hello World!" onto standard output. 
<ul>
</ul></li></ul></div>


<h3>Guide</h3>

<p class="meta">The guide section helps you through the process of
meeting the requirements. Some Tasks will have a long and detailed
guide section, others will have only a brief note. 

</p><p>The following C or C++ program prints a greeting to the <i>standard output</i>. Standard output, often abbreviated <i>stdout</i> is the name of a <i>text stream</i> that your command-line-based program uses to output text to the screen (or other places we will see later). You don't absolutely need to read it just now, but for reference 
<a href="http://www.linfo.org/standard_output.html">a thorough definition of standard output</a> 
is given at <a href="http://www.linfo.org/standard_output.html">LINFO</a>, a great source of Linux information.



</p><p>
</p><pre class="prettyprint linenums prettyprinted"><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L3"><span class="pun">{</span></li><li class="L4"><span class="pln">   printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Hello World\n"</span><span class="pln"> </span><span class="pun">);</span></li><li class="L5"><span class="pln">   </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L6"><span class="pun">}</span></li></ol></pre>


<p>Let's examine the program line by line. Our goal is to use the C library function printf() to compose a chunk of text and send it to stdout. Before we use this function, we need to import a <i>declaration</i> of its name and the arguments it accepts. This is provided with your compiler installation in the file "stdio.h". The compiler knows where to look for it. It's often in /usr/include. Line 1 copies the contents of this file directly into the program code. Below the #include line we can call any functions declared in the included file, including printf().

</p><p>Line 3 defines a function called main() that returns an integer ("int") and takes no arguments ("void"). C programs always start running at the main() function. It's a bit more complicated in C++, but in both languages every program contains exactly one main(), which is called by the OS when the program starts. If you forget to define main(), the compiler will report an error. The <i>body</i> of the function follows from line 4 to line 7, contained in curly braces { ... }.  Unlike Python, the C compiler <i>ignores indentation and newlines completely</i>: they are only used to lay out the code for humans to read. Spaces, tabs and newlines do nothing except separate the <i>tokens</i> - the linguistic atoms - of the language.

</p><p>Line 5 uses printf() to write a text string to stdout. As in many other languages, C strings are a sequence of characters contained within double-quote characters "like this". We will come back to the details of C strings later. The string "Hello World\n" ends with a two-character <i>escape sequence</i> that represents the newline character.  This is different than a print statement in Python that automatically ends the line for you:  the C function printf() does not.
To have a newline in output, we have to represent it with this special escape sequence.

</p><p>Line 5 is our first <i>statement</i>, a block of code that does some work. Statements end with a semicolon. This is different to Python which uses newlines to end statements. 

</p><p>Line 6 causes the main() function to <i>return</i> the integer value 0 (zero) as the result of the function. Back on line 3 we promised that the main function would return an integer, and the compiler would warn us if we forgot to do so. Since this is the main() function, the caller is the command shell which <i>invoked</i> (ran) the program, which receives the value zero as the program's result. C programs always return an integer, and programmers conventionally use this value to indicate that the program was successful by returning zero, or a non-zero error code if something went wrong. We return zero to indicate that we detected no problems.



</p><div class="steps">
<h4>Building the program</h4>

<p>Follow these steps to build and test your program.

</p><ol>
<li>Make sure you are in your lab working copy directory "1" by following the steps above.
</li><li>Open a text editor. gedit is installed for you in CSIL, easily available on all Linux systems, runs in a window and uses the well-known Windows keybindings. Of course, you can use any other text editor you like.
</li><li>Type in the code from the box above into a new file and save it as "t1.c". C files conventionally have a .c suffix.  
</li><li>Compile the source code file to create a runnable program like so:
<pre>$ cc t1.c
</pre>
</li><li>If the program compiled correctly, the compiler created a new file in the current directory called a.out containing your executable program. If you get error messages instead <b>read them carefully, top to bottom</b> and edit the code to fix the first reported error, then compile again. Once all looks well, run your program using its name like so: <pre>$ ./a.out</pre> (where "./" means "this directory"). You should see the expected output on your console: <pre>Hello World</pre>
</li><li>Specify a more descriptive name for your program than the default a.out with the compiler output name  option -o:
<pre>$ cc -o hello t1.c
$ ./hello
Hello World
</pre>
</li></ol>

<p>You now have a working program written in C and built with your bare hands using only the command line. Not bad.
</p></div>

<p>What did we just do? <i>Building</i> a program from source code involves several steps. <a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/details.html">You can read about them in some detail here.</a> In practice you will almost always let the compiler handle the details for you, so we'll focus on writing code. 

</p><p>You have copied some code, compiled it into an executable, and run it. Did it do the right thing? Does the output satisfy the Requirements section above? 

</p><p>The required output is "Hello World!" followed by a newline, but if you copied it exactly as written above, the program omitted the exclamation mark. 

</p><h3>Testing and debugging the program</h3>

<p>Testing is extremely important, and beginners often underestimate how much time and effort is required for good testing. In this case the test is easy and can be done by a human directly: does the output text match exactly the required text?

</p><p>Standard practice in software engineering, and for these labs, is to
test the output of all your programs using automated scripts called
"unit tests". A unit test is a very powerful tool for figuring out if
your program works properly. It is much easier to write a
nearly-correct program than a really-correct program. A good test will
test to see if your requirements are met by trying a variety of valid
inputs and checking for the expected output. Writing and using tests
can significantly help with the quality of your software. You should write tests to make sure your code is correct before submission in all but the most trivial programs.

</p><p>The online evaluation system uses unit tests for all your
tasks. After submission, the tests run automatically. If you pass all
the tests, you have successfully completed the task.

</p><p>Now fix the error in code in "t1.c" by adding the missing exclamation
point. Compile and run it, and verify that it now produces the correct output.

</p><p>Now your program meets the Requirements and you are ready to submit it.

</p><h3>Submitting your program for evaluation</h3>

<p></p><p>First, add your new source code file to
the svn repo, then commit all changes to the remote server.

</p><div class="steps">
<pre>$ svn add t1.c
$ svn commit -m "t1 works, so I'm submitting it"
</pre>

</div>

<h4>Getting your results</h4>
<p>When the online tests have run, the results are recorded in files committed to your code repository. 

</p><div class="steps">

In order to retrieve the result files, you need to update your working copy. This will fetch any files that changed remotely.

<b>THESE STEPS WILL ONLY WORK AFTER THE TESTS HAVE RUN - THEY RUN OVERNIGHT.</b>

<pre>$ svn update</pre>

<p>A new directory should now exist in the current working directory, called "RESULTS", containing a text file for each tested task, named "n.txt", where 'n' is the task number. To read the file, either cat it to the terminal, e.g.

</p><pre>$ cat RESULTS/1.txt</pre>

or open it in an editor:

<pre>$ gedit RESULTS/1.txt</pre>

as you prefer.

</div>

<p>You may commit solutions to tasks at any time until the end of the semester. You can submit any number of solutions. There is no penalty for repeated attempts. 

</p><p>In this class the online tests run every few hours. We could run for you right away, but the delay has two purposes:

</p><ol>
<li>It means you need to test your programs yourself, and not rely on the online tests for your compile-test-debug cycle. Remember, testing is a critical skill in itself. 
</li><li>It simulates the experience of contributing to a very large piece of software, where full-scale builds and tests can take hours or days. 
</li></ol>


</div>

<!--
<p>Note that the server tests all the tasks for the week's lab every time you commit. It will stop testing at the first failure. When you pass all tests for all tasks, you have passed the lab. Until then, let's carry on...
-->

<h3>while( ! labs_complete ){ ... }</h3>

<p>The first task is complete. The remaining tasks have the same workflow:
</p><ol>
<li>read the preamble that introduces a topic
</li><li>read the Requirements
</li><li>read the Guide
</li><li>think, and maybe repeat the prior steps
</li><li>implement some code
</li><li>test, and repeat last step until your code passes the test
</li><li>commit changes
</li><li>receive feedback from the automated tester (next day)
</li>

</ol></div>

<div class="task" id="t_types">
<h2>2. Native types, printf()</h2>

<p>C is a <i>strongly typed</i> language. That is, all variables have
 a <i>type</i> that identifies the kind of data they store. Types
 include integers, floating point numbers, and characters.  Every
 variable has a <i>value</i> which is the data it stores. A
 variable's type is specified at its creation. 

 </p><p>The value of a variable can change, but its type can not. Thus C
 is a <i>statically typed</i> language. This is fundamentally
 different to Python, where variables could contain different things
 during their lifetime.

</p><p> The advantages usually claimed for strong, static typing are:

</p><ol>
<li>Explicit statement of intent: you tell the compiler and people reading the code what kind of data you are manipulating.
</li><li>Error prevention at compile time: if you violate your stated intent, the compiler lets you know right away.
</li></ol>

<h4>Variables and output</h4>

Let's look at a C program that creates some variables and prints them:

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L3"><span class="pun">{</span></li><li class="L4"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L5"><span class="pln">  </span><span class="kwd">float</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3.14159</span><span class="pun">;</span></li><li class="L6"><span class="pln">  </span><span class="kwd">char</span><span class="pln"> c </span><span class="pun">=</span><span class="pln"> </span><span class="str">'+'</span><span class="pun">;</span></li><li class="L7"><span class="pln">&nbsp;</span></li><li class="L8"><span class="pln">  </span><span class="com">// this is a comment</span></li><li class="L9"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"here: %d %f %c\n"</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> pi</span><span class="pun">,</span><span class="pln"> c </span><span class="pun">);</span></li><li class="L0"><span class="pln">&nbsp;</span></li><li class="L1"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L2"><span class="pun">}</span></li></ol></pre>

<p>Which produces this on stdout:

</p><pre>here: 0 3.141590 +
</pre>


</div>


<p>We initialize the variables to a value with the "=" operator. C does not require that variables be initialized, but it's a good practice so we will always do so. 

</p><p>Line 9 is a <i>comment</i>. As in most languages, comments are notes for human readers only, and are ignored by the compiler. Comments come in two styles:

</p><pre class="prettyprint prettyprinted" style=""><span class="com">/* The  multi-line comment style: everything between the 
   slash-star and star-slash is ignored */</span><span class="pln">
</span><span class="com">// The single-line comment style: the remainder of the line is ignored.</span></pre>


<p>Line 10: printf() allows you to print all the native variable types. Using printf() is similar to using the "%" idiom in Python's print() function. printf() is less flexible about its input than Python's print(), but you can do a lot with it. 

</p><p>The first argument to the printf() function is a "format
string". This is a template that specifies the text to output,
including <i>specifiers</i>: codes that begin with "%" that are
to be replaced by text representing the values of subsequent arguments to
printf. In the example, the format string is "here: %d %f %c\n". This
tells printf that the next three arguments will be an integer decimal
(%d), a floating point decimal (%f) and a character (%c). The compiler
will check that you supplied the correct number and type of arguments.

</p><p>Notice that the floating point number was printed with a zero on the end that did not appear in the source code. This is because printf() prints the value of a float to a default precision. This can be set explicitly by stating how many digits you want after the decimal point, e.g:

</p><pre class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">float</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3.14159</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%.2f\n"</span><span class="pun">,</span><span class="pln"> pi </span><span class="pun">);</span></pre>

<p>Which prints

</p><pre>3.14
</pre>

<p>Above we said that printf() is expecting a sequence of <i>variables</i> after the format string. In fact, any <i>expression</i> can be used. An expression in C is a sequence of variables, operators and function calls. The following are valid simple expressions:

</p><pre class="prettyprint prettyprinted" style=""><span class="pln">a
a</span><span class="pun">+</span><span class="pln">b
a</span><span class="pun">*(</span><span class="pln">b</span><span class="pun">+</span><span class="pln">c</span><span class="pun">)</span><span class="pln">
a</span><span class="pun">*</span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span></pre>

<p>The result of any given expression is always a value with a type. This means that an expression can be used anywhere a value is expected, such as following the format string in a call to printf(). For example, the following is valid:

</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="kwd">int</span><span class="pln"> a</span><span class="pun">=</span><span class="lit">2</span><span class="pun">;</span></li><li class="L1"><span class="kwd">int</span><span class="pln"> b</span><span class="pun">=</span><span class="lit">10</span><span class="pun">;</span></li><li class="L2"><span class="pln">&nbsp;</span></li><li class="L3"><span class="pln">printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"the product of a and b equals %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">*</span><span class="pln">b </span><span class="pun">);</span></li></ol></pre>




<!-- <p>See the table in the Guide that lists all the available specifiers. -->

<p>That's the basics of text output in C. 

</p><h3>Types and storage size</h3>
<p> C has several native (i.e. predefined)  variable types. They differ by the kind of value they store and by the range of possible values.

 Here are the most commonly used:

</p><table class="wikitable">
<caption>Standard integer types</caption>
<tbody><tr>
<th>Type specifier</th>
<th>Minimum width (bits)</th>
<th>Minimum value</th>
<th>Maximum value</th>
</tr>
<tr>
<td><tt>char</tt></td>
<td style="text-align: right">8</td>
<td style="text-align: right">-127</td>
<td style="text-align: right">127</td>
</tr>
<tr>
<td><tt>unsigned char</tt></td>
<td style="text-align: right">8</td>
<td style="text-align: right">0</td>
<td style="text-align: right">255</td>
</tr>
<tr><td><tt>int</tt></td>
<td style="text-align: right">16</td>
<td style="text-align: right">-32,767</td>
<td style="text-align: right">32,767</td>
</tr>
<tr>
<td><tt>unsigned int</tt></td>
<td style="text-align: right">16</td>
<td style="text-align: right">0</td>
<td style="text-align: right">65,535</td>
</tr>
<tr>
<td><tt>long</tt></td>
<td style="text-align: right">32</td>
<td style="text-align: right">-2,147,483,647</td>
<td style="text-align: right">2,147,483,647</td>
</tr>
<tr>
<td><tt>unsigned long</tt></td>
<td style="text-align: right">32</td>
<td style="text-align: right">0</td>
<td style="text-align: right">4,294,967,295</td>
</tr>
</tbody></table>


<table class="wikitable" width="80%">
<caption>Floating-point types</caption>
<tbody><tr>
<th rowspan="2">Type specifiers</th>
<th colspan="2">Precision (decimal digits)</th>
<th colspan="2">Exponent range</th>
</tr>
<tr>
<th>Minimum</th>
<th>IEEE 754</th>
<th>Minimum</th>
<th>IEEE 754</th>
</tr>
<tr>
<td><tt>float</tt></td>
<td align="center">6</td>
<td align="center">7.2 (24 bits)</td>
<td align="center">±37</td>
<td align="center">±38 (8 bits)</td>
</tr>
<tr>
<td><tt>double</tt></td>
<td align="center">10</td>
<td align="center">15.9 (53 bits)</td>
<td align="center">±37</td>
<td align="center">±307 (11 bits)</td>
</tr>
<tr>
<td><tt>long double</tt></td>
<td align="center">10</td>
<td align="center">34.0 (113 bits)</td>
<td align="center">±37</td>
<td align="center">±4931 (15 bits)</td>
</tr>
</tbody></table>

There are also <i>pointer</i> types for each one of these. We will discuss pointers later.

<p><a href="http://en.wikipedia.org/wiki/C_syntax#Primitive_data_types">A complete list of the native  types is available at Wikipedia</a>.

</p><p>Why have all these types? The most important distinction is between integer and floating point types, which represent numbers differently. Integer types represent integer values exactly, but over a limited range, with the range determined by the number of bits. Floating point types represent real-number values approximately, with the precision of the approximation determined by the number of bits. 

</p><p>We could manage with one type for each of integer and floating point, but C was designed with compactness and efficiency in mind. Thus C allows (indeed, requires) the programmer to specify the   storage space vs. range/precision trade-off for each variable. This design decision was perhaps easier to justify in 1971 than today, but memory is still precious on your smartphone, and even more so on a microwave oven and on the robots currently on Mars.

</p><p>Notice that the caption in the integer table says <i>minimum width</i>. This is because the C standard says only that integers must be at least this size. They can be larger, and your compiler will use the sizes that are most efficient for your machine. Your next exercise is to write a program to find out the sizes of all these types on the machine that runs it.

</p><h3>Requirements</h3>

<div class="req">
<ul>
<li>Write a new C program in the file t2.c.
</li><li>Write a program that outputs the storage size <b>in bits</b> of each type from the tables above on standard output. 
</li><li>The sizes should be listed in the order they appear in the preceding tables.
</li><li>Output values should be contained on single line, each separated by a single ' ' (space) character. </li><li>The line should end with a newline.
</li><li>Example output: <pre>8 8 16 16 32 32 32 64 128</pre>

<op>Note that the exact values printed will probably be different - very likely larger - on your machine. The values in this example was taken from a vintage 1980s computer.
</op></li></ul></div>

<h3>Guide</h3>

<p>C provides a sizeof() operation that tells you the storage size of any type <b>in bytes</b>. For example:

</p><pre class="prettyprint  prettyprinted" style=""><span class="pln">printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%lu\n"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span></pre>

Results in:

<pre>4</pre> on my machine. Note this is larger than the minimum 2 bytes required by the standard. This is because the architecture of my machine handles data in 4-byte chunks more efficiently than 2-byte chunks. 

<p>The printf() format string contained the "%lu" format specifier, which prints a unsigned long integer type. I chose this format because on my 64-bit machine sizeof() outputs an unsigned long (storage size can only be positive). If you are using a 32-bit operating system, you might need to use "%u" instead of "%lu". The compiler will complain if you have the wrong format.

</p><p>sizeof() also accepts a variable name for its argument. It figures out the type automatically:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">=</span><span class="lit">73</span><span class="pun">;</span><span class="pln">
printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%u %lu\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">);</span></pre>

Results in:

<pre>73 4</pre> 

<p>Note that the requirements ask for the value in bits and not bytes. There are 8 bits in a byte.

</p><p>Do not be tempted to just print the example output. Your code might be tested on a very weird machine.

</p><p>As reminder, here's an example of building and running your new program:

</p><pre>$ gcc -o sz t2.c
$ ./sz
8 8 16 16 32 32 32 64 128
$
</pre>


<h3>Testing your program</h3>


<p>Once you believe your program meets the requirements, you are ready to submit. Remember, you won't get feedback until tomorrow, so think about how you might test your program before submission to maximize the chances of it being correct. For example, you might find out which CPU your machine has and look up what its native sizes are.

</p><h3>Submission</h3>

<p>Submit your solution by checking it into svn as before:

</p><div class="steps">
<pre>$ svn add t2.c
$ svn commit -m "t2 submission"
</pre>
</div>



<div class="task" id="t_pointers">
<h2>3. Input and pointers</h2>

<p>Now let's look at a C program that inputs an integer from the user and echoes it back:

</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></li><li class="L1"><span class="pln">&nbsp;</span></li><li class="L2"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span></li><li class="L3"><span class="pun">{</span></li><li class="L4"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L5"><span class="pln">&nbsp;</span></li><li class="L6"><span class="pln">  printf</span><span class="pun">(</span><span class="str">"Enter an integer: "</span><span class="pun">);</span></li><li class="L7"><span class="pln">&nbsp;</span></li><li class="L8"><span class="pln">  scanf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">i </span><span class="pun">);</span></li><li class="L9"><span class="pln">  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Your integer was: %d\n"</span><span class="pun">,</span><span class="pln"> i </span><span class="pun">);</span></li><li class="L0"><span class="pln">&nbsp;</span></li><li class="L1"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L2"><span class="pun">}</span></li><li class="L3"><span class="pln">&nbsp;</span></li></ol></pre>

<p> There are two new things on line 9. The function scanf() is roughly the inverse of printf(), reading text from <i>standard input</i>, a text stream directly analogous to standard output but in the other direction. Text from the shell is delivered to a program's standard input ("stdin" for short) and is queued there until the program chooses to read it. The shell program and the computer's operating system work together to make this happen. We will see later that this simple scheme can be very powerful.


</p><p>The arguments to scanf() are a format string, similar to that of
  printf(), which is a template to be matched against the input. The
  format string specifiers (starting "%") indicate that the text in
  this place in the input string should be interpreted as a specific
  type, and stored in the variable indicated by the next argument. A
  variable of a suitable type must be supplied following the format
  string, and they are used in order.

</p><p>The format string argument to scanf "%d"  says we should interpret the
entire line as a decimal integer. Whitespace around the number is ignored.

</p><p>Since scanf() is expecting a decimal integer, we have to supply a variable in which to store the value. We created an integer for this purpose  on line 5. So what is the purpose of the ampersand '&amp;' before the argument 'i' on line 9?

</p><h4>Pass by value</h4>

<p>A fundamental feature of C is that arguments to functions are <i> passed by value</i>. Inside the called function, we see only the value of the arguments we were called with. If we do this:

</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L1"><span class="pln">  scanf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> i </span><span class="pun">);</span><span class="pln"> </span><span class="com">// BUG!</span></li></ol></pre>

<p>Then scanf() sees the format string as its first argument, and the value zero as its second argument. This is no use to scanf()! It needs to store the value it has extracted from the input string somewhere. We wanted to tell scanf() about the variable i, not the value of variable i. How do we get around this apparent limitation?

</p><h4>Pointers</h4>

<p>The answer is a very important concept in C: the <i>pointer</i>. The pointer allows us to represent where things are stored in memory. This is a simple idea, but pointers are often considered tricky. 

</p><p>Computer Architecture reminder: The computer makes memory available to your program as a simple <i>address space</i>, with each byte of memory having a unique numeric address, numbered from 0 to the size of the space. This is determined by your machine type, but is typically 2^32 (4GB or around 4.3 billion bytes) or 2^64 (a <i>very</i> large number). Every address contains a single value from 0 to 2^8 (255). The address space can be visualized as a stack of mailboxes, numbered from zero, each containing a number. 

</p><p style="text-align: center;"><img src="./CMPT127 Lab 1_files/mailboxes.jpg">

</p><p>This point is crucial: each mailbox <i>has an address</i>, for example 114 in the picture. And that mailbox <i>contains a value</i>. If you open the door of mailbox 114 and you see a note with "93" written on it, we say the value 93 is stored at address 114. 

</p><p>If you have used a spreadsheet, you are familiar with this idea. The address of a cell is its coordinate (e.g., C2), and the value of the cell is the number it contains. The memory space of a C program is like a spreadsheet with only one column. 

</p><p>Consider this sketch of our program's one-column address space:

</p><pre>Address   Value
2^n          0
  .          .
  .          .
  7          0
  6          0
  5          0
  4         42
  3          0
  2          0
  1          0
  0          0
</pre>

<p> The address space is listed on the left - the stack of uniquely numbered memory slots,  and the value contained in each listed on the right. The value in memory address 4 is 42. Conversely, the <i>address of</i> that byte with value 42 is 4. 

</p><p>Now we can see how variables are actually implemented in C. When you declare a variable, e.g., <tt>char c=42;</tt>, the compiler chooses a currently unused address to contain it, say address 4, then writes the initial value 42 into the memory at that address. Every time the program refers to the value of c, this means the value stored at address 4.

</p><p>Often you need to manipulate values larger than 2^8. To support this the compiler allocates a sequence of addresses with enough space to store a value of the variable's type. The lowest-numbered address is the <i>address of</i> the variable. The <i>int</i> type is used to store integers. It is often 32 bits long and thus need 4-bytes of address space. In our example, the compiler has decided that integer <tt>i</tt> will be stored in the 4 bytes starting at address 4. The value of 42 for <tt>i</tt> fits in the first byte, but we might increase it later such that addresses 5, 6 and 7 would have non-zero values too. 

</p><pre>Address   Value
2^n          0
  .          .
  .          .
  7          0                  |   byte 3 
  6          0                  |   byte 2
  5          0                  |   byte 1
  4         42     &lt;---- int i -    byte 0 
  3          0
  2          0
  1          0
  0          0
</pre>

<p>After compilation, your integer variable originally called <tt>i</tt> or <tt>highscore</tt> or <tt>answer_to_everything</tt> just becomes "the value of the 4 bytes starting at address 4 representing an integer". Variable names are just for humans and the compiler. 

</p><p><b>It's important to remember this simple model of data storage in C: the computer uses both (i) an <i>address</i> to locate the start of sequence of bytes; (ii) a <i>type</i> to understand how long the sequence is and how to interpret it.</b>

</p><p>Python and many other 'high level' languages have different storage models and you rarely have to think about them. That's part of what 'high level' means. C allows/requires you to think about data storage more directly.

</p><h4>Pointers solve the pass by value problem</h4>

<p>At this point you may have figured out the purpose of the ampersand operator '&amp;'. It means "address of" the variable to its right. We can fix the fragment above using this operator:

</p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><span class="pln">  </span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></li><li class="L1"><span class="pln">  scanf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">i </span><span class="pun">);</span><span class="pln"> </span><span class="com">// fixed using &amp;</span></li></ol></pre>

<p>Now scanf() receives the format string followed by the <i>address of</i> variable <tt>i</tt>. If <tt>i</tt> has the address 68, then scanf() receives the value 68. It now knows where to store the integer it reads from standard input. A value that represents a memory address is called a <i>pointer</i>, since it <i>points to</i> where its target is stored.

</p><p>Remember: pointers allow programs to represent and manipulate memory addresses. This is a very powerful tool. We have seen how it solves the apparent limitation of the pass-by-value mechanism. We will come back to pointers later. <!--, e.g. to explain how that format string argument to scanf() is handled. -->

</p><p>Many languages, e.g., Java, do not allow you to use pointers, and have <i>references</i> instead. These are implemented internally as pointers, with an extra little safety net limiting how you use them. C has only pointers, for simplicity. C++ has both pointers and references. 

</p><p>Now you know how to pass a pointer into scanf(), we are ready for the task:

</p><h3>Requirements</h3>

<div class="req">
<ul>
<li>Write a new C program in the file t3.c.
</li><li>Write a program to read a floating point value from standard input, then
  output
  <ol>
    <li>the largest integer smaller than or equal to this value;
    </li><li> the nearest integer to this value, with halfway values rounded away from zero;
    </li><li>the smallest integer larger than or equal to this value
</li></ol>
</li><li>The output integers should be separated by a space character and followed by a newline character.
</li><li>The output values should not have any trailing zeros: e.g. "2" not "2.0".
</li><li>Sample input: <pre>3.1415</pre>
</li><li>Corresponding output: <pre>3 3 4
</pre> 

</li></ul></div>

<h3>Guide</h3>

<p>The format string syntax for scanf() is very nearly the same as for printf(). The format specifier for floating point numbers is "%f". 

</p><p>C comes with the <i>standard library</i>, which contains many useful basic functions, including printf() and scanf(), and many mathematical functions. These functions and their documentation <i>man pages</i> are available on almost all platforms, via the <i>man</i> program we used briefly above.

</p><p>For example, you can look up your local man page for scanf() like so:

</p><pre>$ man scanf</pre>

<p>The (very detailed) man page for scanf and related functions lists all the format strings it understands. You only need "%f" for this task.

</p><p>Press the 'q' key to exit the man page viewer.

</p><p>Notice that the required header(s) are listed at the top of the man page for each function. The exact headers needed varies slightly by system, so check your local man pages.

</p><p>The man page system is widely available and usually very detailed. The main problem with it is that you need to know the name of what you're looking for. Happily, all the web pages are online and indexed by the web search engines. Double check your local man pages after looking online, due to the minor differences between platforms. 

</p><p>Three functions will be helpful for this task: floor(), ceil() and round().

</p><div class="steps">
<p>To see what each function does, check the system manual page like so:

</p><pre>$ man floor
$ man round
$ man ceil</pre>

<p>Again, press the 'q' key to exit the man page viewer.
</p></div>

<p>These and most other math functions require the math.h header:

</p><pre>#include &lt;math.h&gt;</pre>

<p>Note that these functions return values of type <b>double</b> and not <b>int</b>. Thus you need the appropriate printf() format string if you print their results directly.

</p><h4>Linking a library</h4>
<p>The functions declared in math.h are not built-in to C. They are optional extras that are available as standard in most installations. The core of C is very small, and it comes with a <i>standard library</i> of extras, including these math functions. To use them you have to <tt>#include</tt> the math.h file, and then <i>link</i> the math library into your program, which adds the code for the math functions you use into your program. This is done explicitly in the compile command like so:

</p><div class="steps">
<pre>$ gcc t3.c -lm</pre>
</div>

<p>The <tt>-lm</tt> suffix means link (-l) the math library (m). C tools are terse like that. The link command comes after the name of the source file(s), so that the compiler knows which functions are needed from the library.


</p><h3>Testing your program</h3>

<p>Once you believe your program meets the requirements you are ready to submit.

</p><h3>Submission</h3>

<p>Submit your solution by checking it into svn as before:

</p><div class="steps">
<pre>$ svn add t3.c
$ svn commit -m "t3 submission"
</pre>
</div>

</div>

<!-- -------------------------------------------------------------- 

<div class="homeworkbegins">
Lab session complete. Homework starts here.
</div>
-->

<div class="task" id="t_conditions">
<h2>4. Conditions with if and else, return values </h2>

The previous task produced a very fragile program. What if the user typed in something than could not be interpreted as a floating point number? Try it and see what happens. Does it make sense?

<p>We have reached a very important point. Assuming your code perfectly meets the requirements above, you can say it is correct. But "correct" is defined by reference to the requirements. This code is not robust when the user is free to type in arbitrary things into standard input. We can improve the requirements by specifying what the program should do in the case of failures. It is important to see that correct code may not be reliable in the real world, and that the task of specifying requirements is a large part of the work of programming. 

</p><p>To write robust software that does the right thing even when used roughly, we first need to extend the requirements to specify what to do when things go wrong. Then in the code we test things as we go along, using <i>conditionals</i>: keywords that change the program's behaviour depending on the value of a statement at the time it is executed. C's basic conditional is <tt>if</tt> and it has the form:

</p><pre>if( statement )
{
 /* this block is executed if and only if 
  _statement_ evaluates to true (non zero) */
} 
</pre>

<p>For example:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">if</span><span class="pun">(</span><span class="pln"> s </span><span class="pun">&gt;</span><span class="pln"> highscore </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  highscore </span><span class="pun">=</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></pre>

<p>An optional <tt>else</tt> block can be added that will run only if the condition is false. Thus you can choose between two courses of action, for example:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">if</span><span class="pun">(</span><span class="pln"> s </span><span class="pun">&gt;</span><span class="pln"> highscore </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  highscore </span><span class="pun">=</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Congratulations on a new high score!\n"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">else</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"Bad luck. Try again\n"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre>

<h4>Code blocks and indentation</h4>

<p>The block of code after a conditional is contained in curly braces  { ... }. In Python block structure is indicated by indentation, but in C and many other languages, indentation is not significant, and is only there for the comfort of the human reader. This is still <i>very</i> important, so you should follow the conventional indentation style used here and stick to it. 

</p><h4>Return values</h4>

Functions often return values to the caller. For example, scanf()
returns an integer that indicates the number of successfully assigned
variables, possibly 0 if none were assigned. 

<p>We capture the return value using the <i>assignment operator</i>
<tt>=</tt>. We used this already in variable declarations to indicate an
initial value (this is always a good idea, since C does not usually
initialize variables for you). 

</p><p>Assignment examples:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> a</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="com">// ensures a does not have a random initial value</span><span class="pln">
a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span><span class="pln">   </span><span class="com">// change the value of an already-declared variable</span><span class="pln">

a </span><span class="pun">=</span><span class="pln"> scanf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">b </span><span class="pun">);</span><span class="pln"> </span><span class="com">// if b is set successfully, a will be set to 1. If not, a will be 0.</span></pre>

<p>You should almost always check the return value (or other error-reporting mechanism) for any function call that could possibly go wrong or weird. This is a key basic strategy in <a href="http://en.wikipedia.org/wiki/Defensive_programming">Defensive Programming</a> which aims to protect against
 <a href="http://en.wikipedia.org/wiki/Finagle%27s_Law">Finagle's law</a>. 

</p><h3>Requirements</h3>

<div class="req">
<ul>
<li>Copy your solution t3.c to the new file t4.c.
</li><li>The input is guaranteed to contain at least one non-whitespace character.
</li><li>If the input is well-formed, i.e., can be parsed to a number, the program should behave identically to Task 3: all the requirements of Task 3 still apply except the file name.
</li><li>If the input is not well formed, the program should print a
helpful error message that contains the value returned by scanf() so
that the programmer can compare this number with the scanf()
documentation to figure out what went wrong. (If this program was aimed at end-users, we might design this differently).
</li><li>The error message should be in the form:
<pre>"scanf error: (%d)\n"</pre>
with the scanf() return value between the parentheses.
</li><li>Sample input: <pre>3.1415</pre>
</li><li>Corresponding output: <pre>3 3 4</pre>
</li><li>Sample input: <pre>sausage</pre>
</li><li>Corresponding output: <pre>scanf error: (0)</pre>

</li></ul></div>

<h3>Guide</h3>

<p>You should test the return value of scanf() to decide whether a floating point value was detected in the input.

</p><p>Here's the list of <i>infix</i> comparison operators. When placed between two expressions (hence the term "infix"), these result in a value of false (zero) or true (usually 1, but any non-zero value evaluates true when used in a logical expression). 

</p><p>
</p><table class="wikitable">
<tbody><tr><th>name</th><th>syntax
</th></tr><tr><td>equal to</td><td>==
</td></tr><tr><td>not equal to</td><td>!=
</td></tr><tr><td>less than</td><td>&lt;
</td></tr><tr><td>greater than</td><td>&gt;
</td></tr><tr><td>less than or equal to</td><td>&lt;=
</td></tr><tr><td>greater than or equal to</td><td>&gt;=
</td></tr></tbody></table>

<p>Notice the <i>equal to</i> operator "==" is distinct from the assignment operator "=" . Mixing these up is a common bug for C beginners. Double-check every time you intend to use "==".

</p><h3>Testing and Submission</h3>

<p>Test, test, test again, then submit as usual:

</p><div class="steps">
<pre>$ svn add t4.c
$ svn commit -m "t4 submission"
</pre>

</div>



<p class="meta">Testing and submission instructions will be omitted from now on, unless there is something special about the particular task. Unless otherwise specified, submit a source file called "tX.c" where X is the task number.


</p></div>



<div class="task" id="t_loops">
<h2>5. Loops</h2>

Now our number-rounding program can detect input scanning errors, but it still only works for one number. Let's extend it to handle any number of inputs. For this we need to repeat part of our program to deal with each value that comes. We need a <i>conditional loop</i>. C has only two options: <tt>while</tt> and <tt>for</tt>.

<h4>While loops</h4>

<p>The <tt>while</tt> keyword has the following form:

</p><pre>while( condition )
{
  // this block executes repeatedly as long as
  // condition evaluates true
}
</pre>

<p>For example this code:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">6</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d "</span><span class="pun">,</span><span class="pln"> i </span><span class="pun">);</span><span class="pln">
  i</span><span class="pun">++;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">);</span></pre>

produces the output

<pre>0 1 2 3 4 5
</pre>

<p>The repeating block of code  is again contained in curly braces  { ... }, as with conditionals.

</p><p>Note the use of the <i>increment operator</i> <tt>++</tt> which adds one to its argument. <tt>i++</tt> is a shortcut for <tt>i=i+1</tt>. This, along with the <i>decrement operator</i> <tt>--</tt> are frequently used. Now you know how C++ got its name.

</p><p>The condition can be inverted with the logical <i>not operator</i> <tt>!</tt>, so the following does the same:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> </span><span class="pun">!</span><span class="pln"> (i </span><span class="pun">==</span><span class="pln"> </span><span class="lit">6)</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d "</span><span class="pun">,</span><span class="pln"> i </span><span class="pun">);</span><span class="pln">
  i</span><span class="pun">++;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">);</span></pre>

<p>It is important to note that if the <tt>while</tt> condition is false on the first evaluation, the body of the loop is never executed. Think of it like an <tt>if</tt> statement that repeats until it is false. Occasionally it is useful to have the body of the loop run at least once before testing the condition, so there is an alternate form: the <tt>do-while</tt>, like so:

</p><pre>do 
{
  // this block executes at least once, 
  // then repeats as long as
  // condition evaluates true
} while( condition );
</pre>

<p>For example this code:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">do</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
   i </span><span class="pun">=</span><span class="pln"> getNextValueFromDatabase</span><span class="pun">();</span><span class="pln"> 

</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">while</span><span class="pun">(</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1000</span><span class="pln"> </span><span class="pun">)</span></pre>

<p>will get at least one value from the database, and will repeat this until it fetches a number bigger than 1000. 

</p><p>This is a dangerous example, since if all the values in the database are less than 1000, this program will happily run forever. This could be a nasty bug since your test database is probably different from those of your customers. You should be looking out for problems like this whenever you write a loop. To produce high quality code, you need to be always thinking, "What could possibly go wrong here?"

</p><h4>For loops</h4>
The pattern above, where we initialize a variable, test its value, then perform a loop that changes the value, is so frequently used that it has a special syntax: the <i>for loop</i>, which has the form

<pre>for( initialize; condition; modify )
{
   // this code runs until condition evaluates to false 
}
</pre>

<p>Any valid C expression can be used in each of the three for() components, separated by semicolons. But they are usually quite simple. For example:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">for</span><span class="pun">(</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="lit">6</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d "</span><span class="pun">,</span><span class="pln"> i </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"\n"</span><span class="pln"> </span><span class="pun">);</span></pre>

is functionally identical to our first <tt>while</tt> example.

<p>Every for loop has an equivalent while, and <i>vice versa</i>, so choose whichever is neatest for the loop at hand.

</p><h4>Break</h4>

<p>You can break out of a loop body with the <tt>break;</tt> statement. For example, this code

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">for</span><span class="pun">(</span><span class="pln"> </span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="lit">1000</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> random</span><span class="pun">()</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">100</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="com">// random() is defined in stdlib.h</span><span class="pln">
       </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">

   printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d "</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// prints the value and *then* increments it</span><span class="pln">
</span><span class="pun">}</span></pre>

will print integers in sequence from 0, but has a 1% chance of leaving the loop every time around. The function random() returns a random integer and the % operator is the integer modulus operator, so the code will print consecutive numbers up to 999 or until random() returns a multiple of 100, whichever comes sooner.

<h4>Continue</h4>

<p>You can jump to the beginning of a loop body with the <tt>continue;</tt> statement. For example, this code

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">for</span><span class="pun">(</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="lit">1000</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
   </span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> random</span><span class="pun">()</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">100</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">)</span><span class="pln">
       </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">

   printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d "</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// prints the value and *then* increments it		  </span><span class="pln">
</span><span class="pun">}</span></pre>

will print integers of increasing value, but every loop iteration has has a 1% chance of jumping to the beginning of the loop without printing. Thus this code will continue to loop until it reaches 1000, but might skip a few numbers.

<p>That is all there is to loops in C.

</p><h4>End-of-File</h4>

<p>The standard input stream to your program behaves as if it was a file. One of the most powerful ideas behind the design of the UNIX operating system and environment is that <a href="http://en.wikipedia.org/wiki/Everything_is_a_file">"everything is a file"</a>. Since stdin behaves like a file, it can have an "end". 

</p><p>The shell program connects your typed input to your program's stdin. We can break this connection by typing the special character sequence <b>&lt;ctrl-d&gt;</b>, that is press-and-hold the control key, then press 'd', then release the control key. The shell receives this command, sends a special "End-of-file" or <b>EOF</b> indicator to the connected stdin, and then closes the connection.

</p><p>Inside the running program, the EOF indicator is detected by input functions such  as scanf(). scanf() will return an integer with a special value to indicate EOF. This is often -1, but the actual value depends on your system. The standard library defines the symbol "EOF" which has the correct value for your system. You can use it like so:

</p><pre class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> scanf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">i </span><span class="pun">);</span><span class="pln">

</span><span class="kwd">if</span><span class="pun">(</span><span class="pln"> result </span><span class="pun">==</span><span class="pln"> EOF </span><span class="pun">)</span><span class="pln"> </span><span class="com">// note double-equals for comparison!</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
  printf</span><span class="pun">(</span><span class="pln"> </span><span class="str">"End of file detected\n"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre>

<p>By definition, once an EOF is seen in an input stream, any subsequent read will also return EOF. 

</p><p>We can use the combination of conditional loops and EOF indicator to make the rounding program work for an arbitrary number of input values.

</p><h3>Requirements</h3>

<div class="req">
<ul>
<li>Write a program to read any number of floating point values from standard input, separated by newlines.
</li><li>The input may also contain any number of blank lines, i.e. lines that contain any amount of whitespace followed by a newline.
</li><li>With the exception of blank lines, the input is guaranteed to be well-formed and contain at least one valid floating point value.
</li><li>For each value input, output (as before):
  <ol>
    <li>the largest integer smaller than this value;
    </li><li> the nearest integer to this value, with halfway values rounded away from zero;
    </li><li>the smallest integer larger than this value
</li></ol>
</li><li>For each input value, the output integers should be separated by a space character and followed by a newline character.
</li><li>The output values should not have any trailing zeros: e.g., "2" not "2.0".
</li><li>If no floating point value can be parsed (i.e. a blank line was read) there should be no output. To put it another way: blank lines should be ignored.
</li><li>The program should accept input values on stdin until EOF is reached. 
</li><li>When EOF is reached, print "Done.\n" on line by itself, then exit the program.
</li><li>Sample input: <pre>3.1415
7.11
-15.7
</pre>
</li><li>Corresponding output: <pre>3 3 4
7 7 8
-16 -16 -15
Done.
</pre>

<b>Important Note:</b> your input and output are interleaved in the terminal window, so the <i>appearance</i> of a run of a correct program with the input above is:

<pre>3.1415
3 3 4
7.11
7 7 8
-15.7
-16 -16 -15
</pre>


<p>But it's important to realize that this consists of alterating line of input and output, each three lines long.

</p></li></ul>


</div>


<h3>Guide</h3>

<p>Try to find a solution that is brief and readable, since that is the easiest to write correctly. Less code means less room for typos and more room in your brain to think about it. Readable code means you will be able to understand it whether you next look at it ten minutes or ten months from now. It can be useful to imagine that you are writing the code for a specific human reader. Make the code self-explanatory to them. Impress them with your clarity. My (non-fancy) solution is 20 lines long. If you write more than twice as much as this, think hard, and talk to an instructor or TA about how express the solution more compactly. 

</p><h3>Testing coverage</h3>
<p>Don't forget to test yourself interactively on a variety of inputs. One  is not enough. Your job is to find bugs before our grading system does. Think "what can I possibly do to make it go wrong?". 

</p><p>As always, make sure your program meets the requirements. Here is a key idea: <b>perform a test that covers every requirement</b>, including those about malformed input and empty lines. Your tests should also exercise every line of your program, including every possible branch due to a conditional. This is the principle of <i>coverage</i>. We will talk more about testing strategies later.

</p><p>It's also important to understand that <b>a program that passes all the tests may not be correct</b>. While our online tests aim to cover a variety of input cases, we don't know what's in your program, so we can not guarantee code coverage.

</p><p>Only you can ensure your code is correct!

</p></div>


<div class="task" id="t_stats">

<h2>6. Simple statistics</h2>

An exercise in computing elementary statistics over a set of input values. You will need to loop over a scanf() and check its return value to detect the end of the input.

<h3>Requirements</h3>

<div class="req">
<ul>
<li>Read floating point values from stdin, each separated by a newline, and terminated by EOF. 
</li><li>The input values are in the range [-100,000 to +100,000].
</li><li>The input will contain at least one floating-point value.
</li><li>The input may contain blank lines: these should be ignored.
</li><li>Apart from possible blank lines, the input is otherwise well-formed.
</li><li>At EOF, output:
  <ol>
    <li> the smallest value seen
    </li><li>the largest value seen
    </li><li>the arithmetic mean of all the values seen
  </li></ol>
 all accurate to two decimal places.

</li><li> The output values must be separated by a single space character and followed by a newline character. 

</li><li>Examples:
<ol> 
<li>Input:
<pre>7
5.6
6</pre>

Output:
<pre>5.60 7.00 6.20</pre>

</li><li>
Input:
<pre>11</pre>

Output:
<pre>11.00 11.00 11.00
<pre></pre></pre></li></ol>

</li></ul></div>

<h3>Guide</h3>

<p>Note that you do not have handle arbitrary text in the input: only well-formed numbers and empty lines.

</p><p>The <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">definition of the arithmetic mean</a>.


<!-- <h3>Testing &amp Submission</h3>

<p>As usual.
-->

</p></div>


<div class="task" id="t_drawhisto">

<h2>7. Horizontal graph</h2>

<p>Write a small program that could be useful in the real world. 

</p><h3>Requirements</h3>

<div class="req">
<ol>
<li>Read an arbitrary number of positive integer values from stdin. The values are separated by one or more spaces or newlines (only).
</li><li>The input is guaranteed to be well-formed.
</li><li>On standard output, render a a simple graph representation of the input values, in order, using hash '#' characters as shown in the examples below. The number of hashes printed should be equal to the input value.
</li><li>Your program should output exactly one line per input value. 
</li><li>The value zero should generate an empty line, i.e. just a newline character.
</li><li>Ignore empty lines. Do not output a newline for an empty line.
</li></ol>
</div>

<h3>Guide</h3>

<p></p><h3>Examples</h3>
<ol>
<li>Input: 
<pre>5 4 3 2 1</pre>
Output:
<pre>#####
####
###
##
#
</pre>
</li><li>Input: 
<pre>16
0
4
12</pre>
Output:
<pre>################

####
############
</pre>
</li><li>Input: 
<pre>1 1 3 
2 1</pre>
Output:
<pre>#
#
###
##
#
</pre>
</li><li>Input: 
<pre>3


2
1

</pre>
Output:
<pre>###
##
#
</pre>
</li></ol>

<h3>Guide</h3>
Again your and output are interleaved in the terminal window, so the appearance of a run of a correct program  with first example above is:

<pre>5 4 3 2 1
#####
####
###
##
#
</pre>

<p>But the third example is more messy since the input contained several lines:

</p><pre>1 1 3 
#
#
###
2 1
##
#
</pre>

<p>In the next lab we will see how to use files with stdin and stdout to avoid this unsightly mess. 


</p><h3>Testing &amp; Submission</h3>

<p>As usual. Don't forget the requirement that the program accepts
arbitarily large input, including empty and very large. Test these cases.

</p><p>When testing yourself, don't forget to try small values and ensure that your rendering meets the specifications.


</p><div class="task" id="t_pyramid1">

<h2>8. Pyramid Projection 1</h2>

This exercise has more complex requirements. You can meet them with some quite simple, compact code. The main challenge here is formulating the problem as a computation. 

<h3>Requirements</h3>

<div class="req">
<ol>
<li>Read a line containing three positive integer values greater than 0 from stdin. The values are separated by one or more spaces. 
</li><li>The input is guaranteed to be well-formed.
</li><li>The values represent the width (x dimension), breadth (y dimension) and height (z dimension) of a symmetrical rectangular-based pyramid, respectively. The height is measured perpendicularly from the base of the pyramid. 
</li><li>All values will be in the range [1..50].
</li><li>On standard output, render a view from above the pyramid, showing its rectangular base, i.e., the projection of the pyramid onto the plane z=0. In this view, x increases from left to right, and y increases from bottom to top.
</li><li>Draw the outline of the pyramid with the '#' character. The outline must approximate the pyramid's boundary as shown in the examples below and described in the next two requirements.
</li><li>The top and bottom rows shall be drawn with exactly <i>width</i> '#' characters.
</li><li>For every remaining text row, either one or two '#' characters shall be drawn, covering the left-most and right-most position on that row intersected by the edge of the pyramid,
</li><li> Any non-boundary area inside the shape must be filled with the '.' character.
</li></ol>
</div>

<h3>Guide</h3>

<p>You'll need to use a fixed-width font in your terminal for these shapes to look right in your output. (If the examples below don't look symmetrical in your browser, check that your &lt;pre&gt; font is fixed-width.)

</p><h3>Examples</h3>
<ol>
<li>Input: 
<pre>6 6 4</pre>
Output:
<pre>######
#....#
#....#
#....#
#....#
######
</pre>

</li><li>Input:
<pre>7 4 4</pre>
Output:
<pre>#######
#.....#
#.....#
#######
</pre>

</li><li>Input: 
<pre>1 1 1</pre>
Output:
<pre>#
</pre>

</li></ol>

<h3>Testing &amp; Submission</h3>

<p>As usual.

</p><p>When testing yourself, don't forget to try small values and ensure that your rendering meets the specifications.

</p></div>

<div class="task" id="t_pyramid2">

<h2>9. Pyramid Projection 2</h2>

<h3>Requirements</h3>

<div class="req">

The requirements are the same as for the previous task, but this time pyramid must be rendered from the side:
<ol>

<li>(Inherit requirements 1-4, 6 and 7 from the previous Task)
</li><li>On standard output render the view from the front of the pyramid, showing its triangular side, i.e., the projection of the pyramid onto the plane y=0. In this view, x increases from left to right and z increases from bottom to top.
</li><li>The base of the pyramid should be drawn as a row of exactly <i>width</i> '#' characters. 
</li><li>The top row (tip of the pyramid) should be drawn such that every character position that intersects the boundary of the pyramid is drawn.
</li><li>For every remaining text row, either one or two '#' characters shall be drawn, covering the left-most and right-most position on that row intersected by the edge of the pyramid, as shown in the shaded regions in this image of a pyramid of width==6, breadth==6, height==4:
</li><li>Each line should be as few characters as possible:the final '#' character on each line should be immediately followed by a newline.
<p style="text-align: center;"><img src="./CMPT127 Lab 1_files/pyramid.png">
  </p>
</li></ol>
</div>

<h3>Guide</h3>

<p></p><p>Don't be tempted to be artistic and make the pyramid "look right" by insisting on a 1-pixel point at the top. Be sure to meet the requirements exactly. Consider example 3 below and the image above, for example. Notice that the requirements imply that your rendering will be symmetrical left-to-right.

</p><p>Minor hint: first draw the triangle upside down until the geometry is right, then fix the loop over height to flip it the right way up.

</p><p><a href="http://www.cs.sfu.ca/CourseCentral/127/alavergn/lab/1/t8_hint.c">Major hint, if you need it.</a> 

</p><h3>Examples</h3>
<ol>
<li>Input: (matches the image above)
<pre>6 6 4</pre>
Output:
<pre>  ##
 #..#
#....#
######
</pre>

</li><li>Input:
<pre>7 4 4</pre>
Output:
<pre>  ###
 #...#
#.....#
#######
</pre>

</li><li>Input: 
<pre>1 1 1</pre>
Output:
<pre>#
</pre>


</li><li>Input: 
<pre>12 6 6</pre>
Output:
<pre>     ##
    #..#
   #....#
  #......#
 #........#
############
</pre>

</li><li>Input: 
<pre>40 10 4</pre>
Output:
<pre>               ##########
          #..................#
     #............................#
########################################
</pre>

</li></ol>

<h3>Testing &amp; Submission</h3>

<p>As usual.

</p><p>When testing yourself, don't forget to try small values and ensure that your rendering meets the specifications.

</p></div>

<!--
<div class="task" id="t_snugfit">

<h2>10: Snug fit</h2>

<p>This task tests your understanding of the native data types and the values they can store. The concept is similar to Task 1 but the code required is a little more complex. 

<h3>Requirements</h3>

<div class="req">
Write a program that:
<ul>
<li>reads a single integer  value from stdin
<li>Output the name of the most restrictive data type that can represent that value on the host machine, followed by a single newline
<li>The type name output shall be one of the types in the table shown with Task 1 above. 
</ul>
</div>

<h3>Guide</h3>

<p>By "most restrictive", we mean:

<ol>
<li>requires as little memory storage as possible AND
<li>Positive integers should use an unsigned integer type
</ol>

<p>Examples:

<ol>
<li>Input: <br>
<tt>45</tt><br>
Output: <br>
<tt>unsigned char</tt>

<li>Input: <br>
<tt>-1</tt><br>
Output: <br>
<tt>char</tt>

<li>Input: <br>
<tt>459876</tt><br>
Output: <br>
<tt>unsigned int</tt>

<h3>Submission</h3>

<p>Commit the single C source file <tt>t10.c</cc> which contains your program.

</div>

-->

<!--
<div class="task">

<h2>ASCII art, redirecting stdin and stdout</h2>

Now we will write a more substantial program. Later in the course we will do some computer graphics and image processing. We need to cover arrays and functions before we can do that, but in the meantime here's an exercise that is at least partly visual, and more fun than adding numbers.

<h3>Requirements</h3>

<div class="req">
<ul>
<li>Write a C program that reads a numerical description of an image from standard input, and renders it as an ASCII-art image on standard output. 
<li>The input is a series of integers in the range [0 : 255], each representing a pixel in a shade of grey from 0 (black) to 255 (white). 
<li>Integers are separated by a space, or by a newline.
<li>W

<li>For every integer read from the command line, output a character according to the following table:

<p><table>
<tr>
<th>Value range
<td class="spaced-table">0 - 24 
<td class="spaced-table">25 - 49
<td class="spaced-table">50 - 74
<td class="spaced-table">75 - 99
<td class="spaced-table">100 - 124
<td class="spaced-table">125 - 149
<td class="spaced-table">150 - 174
<td class="spaced-table">175 - 199
<td class="spaced-table">200 - 224
<td class="spaced-table">225 - 255

<tr>
<th>Character to print
<td class="spaced-table"> ' '
<td class="spaced-table"> '.'
<td class="spaced-table"> ':'
<td class="spaced-table"> '-'
<td class="spaced-table"> '='
<td class="spaced-table"> '+'
<td class="spaced-table"> '*'
<td class="spaced-table"> '#'
<td class="spaced-table"> '%'
<td class="spaced-table"> '@'

</table>

</ul>
</div>

<h3>Guide</h3>

<p class="meta"> From here on, the guide section
will often include links to other material that can be crucial to
solving the task. You should practice consulting online references and
tutorials: this is a significant part of real-world programming. To
encourage you to practice, we use external links instead of writing everything out in the guide. To be absolutely clear: <b>not everything you need to know is contained in our instructions: you need to read around using the links and maybe searching online. This is deliberate and not cause for complaint!</b>


<p>You can solve this task by combining elements from previous tasks. 


<p>You will soon find it tedious to type long lists of numbers into your program's stdin. The shell has a powerful tool to help with this: <i>stream redirection</i>. This allows you to route the stdin and stdout for a program away from the console and into a file. For example, using our hello world program from Task 1, we can do this:

<pre>
$ ./hello > myfile.txt
</pre>

This creates a new file myfile.txt. Anything written to stdout in the hello program is written to the file. To confirm this, inspect the contents of the file:

<pre>
$ cat myfile.txt
Hello world!
$
</pre>

<p>Similarly, we can

<a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">Here is a terse but good introduction to BASH shell programming,</a> including a <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-3.html">section on redirection</a>.

</div>
-->

<!--
<div class="task">

<h2>Task template</h2>

<h3>Requirements</h3>

<div class="req">
<ul>
<li>item
</ul>
</div>

<h3>Guide</h3>

<h3>Testing</h3>

<h3>Submission</h3>

</div>
-->

<div class="labends">
Lab complete. <!-- <a href="../index.html">Back to the list of labs</a>.-->
</div>

 


<!-- replaces keywords in the text above for the correct user and semester -->
<script src="./CMPT127 Lab 1_files/customize.js"></script></div><div id="feedly-mini" title="feedly Mini tookit"></div></body></html>